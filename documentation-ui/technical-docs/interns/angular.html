<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, shrink-to-fit=no"
        name="viewport" />
    <title>DocsAllOver&nbsp;|&nbsp;Technical Docs&nbsp;|&nbsp;HTML</title>
    <meta name="language" content="EN">
    <meta name="coverage" content="Worldwide">
    <meta name="distribution" content="Global">
    <meta name="rating" content="General">
    <meta name="robots" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta name="author" content="Hrishikesh & Rakesh">
    <meta name="subject"
        content="Get the most out of your experience with DocsAllOver by exploring our comprehensive documentation, including installation guides, integration guides, tutorials, blogs, articles, and FAQs">
    <meta name="copyright" content="DocsAllOver">
    <meta name="rating" content="General">
    <meta name="revisit-after" content="2 days">

    <link rel="canonical" href="index.html">

    <meta property="fb:app_id" content="1330655607860200" />
    <meta property="og:site_name" content="DocsAllOver">
    <meta property="twitter:site" name="twitter:site" content="@docsallover">
    <meta property="twitter:creator" name="twitter:creator" content="@docsallover">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9JVTKGBCBW"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'G-9JVTKGBCBW');
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6750041070411469"
        crossorigin="anonymous"></script>

    <!-- Path to manifest.json -->
    <link rel="manifest" href="../../manifest.json">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="DocsAllOver">


    <!-- Chrome for Android theme color -->
    <meta name="theme-color" content="#5271ff">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="DocsAllOver">
    <meta name="apple-mobile-web-app-status-bar-style" content="#5271ff">



    <link rel="apple-touch-icon" href="http://127.0.0.1:8000/static/images/logo-square.png" sizes="">





    <link href="http://127.0.0.1:8000/static/images/logo-square.png"
        media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)"
        rel="apple-touch-startup-image" />



    <!-- Tile for Win8 -->
    <meta name="msapplication-TileColor" content="#ffffff">

    <meta name="msapplication-TileImage" content="/static/images/logo-square.png">


    <link rel="icon" sizes="" href="http://127.0.0.1:8000/static/images/logo-square.png">


    <script type="text/javascript">
        // Initialize the service worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/serviceworker.js', {
                scope: '/'
            }).then(function (registration) {
                // Registration was successful

                console.log('django-pwa: ServiceWorker registration successful with scope: ', registration.scope);

            }, function (err) {
                // registration failed :(

                console.log('django-pwa: ServiceWorker registration failed: ', err);

            });
        }
    </script>



    <meta name="keywords"
        content="HTML, Technical documentation, Web development, Web standards, Web design, Web programming, HTML tags, HTML elements, HTML code, Learn HTML, Docsallover">
    <meta name="keyphrases"
        content="HTML coding and programming, Web development with HTML, HTML standards and best practices, Comprehensive HTML technical documentation, HTML tags and elements for web development, HTML code for web design, Understanding and using HTML for web development">
    <meta property="og:title" content="DocsAllOver | Technical Docs | HTML" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://docsallover.com/technical-docs/html/" />
    <meta name="description" property="og:description"
        content="Explore comprehensive HTML technical documentation, including the latest standards and guidelines for web development. Learn how to create and manage HTML-based websites effectively.">

    <meta name="image" property="og:image"
        content="https://docsallover.com/docsallover/media/category_images/technical_docs/1.png" />
    <meta name="twitter:image" content="https://docsallover.com/docsallover/media/category_images/technical_docs/1.png">

    <meta name="twitter:title" content="DocsAllOver | Technical Docs | HTML">
    <meta name="twitter:description"
        content="Explore comprehensive HTML technical documentation, including the latest standards and guidelines for web development. Learn how to create and manage HTML-based websites effectively.">
    <meta name="twitter:url" content="https://docsallover.com/technical-docs/html/" />
    <meta name="twitter:card" content="summary_large_image">

    <style>
        .ad::-webkit-scrollbar {
            display: none;
        }
    </style>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/boxicons@latest/css/boxicons.min.css">


    <link id="theme-style" rel="stylesheet" href="../../docsallover/static/core/css/theme.css">
    <link rel="stylesheet" href="../../docsallover/static/core/plugins/simplelightbox/simple-lightbox.min.css">
    <style>
        ::placeholder {
            /* Chrome, Firefox, Opera, Safari 10.1+ */
            color: #5271ff;
            opacity: 1;
            /* Firefox */
        }

        :-ms-input-placeholder {
            /* Internet Explorer 10-11 */
            color: #5271ff;
        }

        ::-ms-input-placeholder {
            /* Microsoft Edge */
            color: #5271ff;
        }

        body {
            background-color: #eee
        }

        .card {
            border: none;
            border-radius: 10px
        }

        .c-details span {
            font-weight: 300;
            font-size: 13px
        }

        .icon {
            width: 50px;
            height: 50px;
            background-color: #eee;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 39px
        }

        .badge span {
            background-color: #dae1ff;
            width: 60px;
            height: 25px;
            padding-bottom: 3px;
            border-radius: 5px;
            display: flex;
            color: #5271ff;
            justify-content: center;
            align-items: center
        }

        .text1 {
            font-size: 14px;
            font-weight: 600
        }

        .text2 {
            color: #a5aec0
        }

        .blog {
            background-color: #eee !important;
        }

        @media (max-width: 992px) {
            .offcanvas-collapse {
                position: fixed;
                top: 56px;
                /* Height of navbar */
                bottom: 0;
                left: 100%;
                width: 100%;
                padding-right: 1rem;
                padding-left: 1rem;
                overflow-y: auto;
                visibility: hidden;
                background-color: #343a40;
                transition: transform .3s ease-in-out, visibility .3s ease-in-out;
            }

            .offcanvas-collapse.open {
                visibility: visible;
                transform: translateX(-100%);
            }

        }

        .text-truncated {
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }
    </style>




    <!-- Plugins CSS -->
    <link rel="stylesheet" href="../../docsallover/static/core/plugins/highlightjs/atom-one-dark.min.css">
    <style>
        body {
            background-color: #fff
        }

        .floating {
            position: fixed;
            width: 60px;
            height: 60px;
            bottom: 40px;
            right: 40px;
            background-color: #5271ff;
            color: #fff;
            border-radius: 50px;
            text-align: center;
            font-size: 30px;
            box-shadow: 2px 2px 3px #999;
            z-index: 100;
        }

        .fab-icon {
            margin-top: 16px;
        }

        .theme-icon-holder svg {
            margin-top: 3px;
        }
    </style>



</head>

<body>




    <style>
        @media all and (min-width: 992px) {
            .navbar .nav-item .dropdown-menu {
                display: none;
            }

            .navbar .nav-item:hover .dropdown-menu {
                display: block;
            }

            .navbar .nav-item .dropdown-menu {
                margin-top: 0;
            }
        }
    </style>



    <header class="header fixed-top">
        <div class="branding">
            <div class="container-fluid position-relative">
                <nav class="navbar navbar-expand-lg">
                    <div class="site-logo"><a class="navbar-brand" href="index.html"><img class="logo-icon me-2"
                                src="assets/images/site-logo.svg" alt="logo"><span class="logo-text">Coder<span
                                    class="text-alt">Pro</span></span></a></div>

                    <button class="navbar-toggler collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#navigation" aria-controls="navigation" aria-expanded="false"
                        aria-label="Toggle navigation">
                        <span> </span>
                        <span> </span>
                        <span> </span>
                    </button>

                    <div class="collapse navbar-collapse py-3 py-lg-0" id="navigation">
                        <ul class="social-list list-inline mt-3 mt-lg-0 mb-lg-0 d-none d-xl-flex ms-lg-3 me-lg-3">
                            <li class="list-inline-item"><a href="index.html#"><i
                                        class="fa-brands fa-github fa-fw"></i></a></li>
                            <li class="list-inline-item"><a href="index.html#"><i
                                        class="fa-brands fa-x-twitter fa-fw"></i></a></li>
                            <li class="list-inline-item"><a href="index.html#"><i
                                        class="fa-brands fa-slack fa-fw"></i></a></li>
                            <li class="list-inline-item"><a href="index.html#"><i
                                        class="fa-brands fa-product-hunt fa-fw"></i></a></li>
                        </ul><!--//social-list-->
                        <ul class="navbar-nav ms-lg-auto">
                            <li class="nav-item me-lg-4">
                                <a class="nav-link" href="features.html">Features</a>
                            </li>
                            <li class="nav-item me-lg-4">
                                <a class="nav-link" href="pricing.html">Pricing</a>
                            </li>
                            <li class="nav-item dropdown me-lg-4">
                                <a class="nav-link dropdown-toggle" href="index.html#" id="navbarDropdown" role="button"
                                    data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                    Docs
                                </a>
                                <ul class="dropdown-menu rounded shadow menu-animate slideIn"
                                    aria-labelledby="navbarDropdown">
                                    <li><a class="dropdown-item has-icon" href="docs.html"><span
                                                class="theme-icon-holder me-2"><i
                                                    class="fas fa-home fa-fw"></i></span>Docs Home</a></li>

                                    <li>
                                        <div class="dropdown-divider m-0"></div>
                                    </li>

                                    <li><a class="dropdown-item has-icon" href="docs-page.html#section-1"><span
                                                class="theme-icon-holder me-2"><i
                                                    class="fas fa-map-signs fa-fw"></i></span>Introduction</a></li>
                                    <li><a class="dropdown-item has-icon" href="docs-page.html#section-2"><span
                                                class="theme-icon-holder me-2"><i
                                                    class="fas fa-arrow-down fa-fw"></i></span>Installation</a></li>
                                    <li><a class="dropdown-item has-icon" href="docs-page.html#section-3"><span
                                                class="theme-icon-holder me-2"><i
                                                    class="fas fa-box fa-fw"></i></span>APIs</a></li>
                                    <li><a class="dropdown-item has-icon" href="docs-page.html#section-4"><span
                                                class="theme-icon-holder me-2"><i
                                                    class="fas fa-cogs fa-fw"></i></span>Integrations</a></li>
                                    <li><a class="dropdown-item has-icon" href="docs-page.html#section-5"><span
                                                class="theme-icon-holder me-2"><i
                                                    class="fas fa-tools fa-fw"></i></span>Utilities</a></li>
                                    <li><a class="dropdown-item has-icon" href="docs-page.html#section-6"><span
                                                class="theme-icon-holder me-2"><i
                                                    class="fas fa-laptop-code fa-fw"></i></span>Web</a></li>
                                    <li><a class="dropdown-item has-icon" href="docs-page.html#section-7"><span
                                                class="theme-icon-holder me-2"><i
                                                    class="fas fa-tablet-alt fa-fw"></i></span>Mobile</a></li>
                                    <li><a class="dropdown-item has-icon" href="docs-page.html#section-8"><span
                                                class="theme-icon-holder me-2"><i
                                                    class="fas fa-book-reader fa-fw"></i></span>Resources</a></li>
                                    <li><a class="dropdown-item has-icon" href="docs-page.html#section-9"><span
                                                class="theme-icon-holder me-2"><i
                                                    class="fas fa-lightbulb fa-fw"></i></span>FAQs</a></li>
                                </ul>
                            </li>
                            <li class="nav-item me-lg-4">
                                <a class="nav-link" href="contact.html">Contact</a>
                            </li>
                            <li class="nav-item me-lg-4">
                                <a class="nav-link" href="login.html">Login</a>
                            </li>
                            <li class="nav-item me-lg-0 mt-3 mt-lg-0">
                                <a class="btn btn-primary text-white" href="signup.html">Sign up</a>
                            </li>
                        </ul>
                    </div>
                </nav>

            </div><!--//container-->
        </div><!--//branding-->
    </header><!--//header-->


    <script>
        (() => {
            'use strict'

            document.querySelector('#navbarSideCollapse').addEventListener('click', () => {
                document.querySelector('.offcanvas-collapse').classList.toggle('open')
            })
        })()
    </script>



    <div class="docs-wrapper">

        <div id="docs-sidebar" class="docs-sidebar">
            <nav id="docs-nav" class="docs-nav navbar">
                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="index.html#section-1">
                            <span class="theme-icon-holder me-2">
                                <i class="fa fa-signs-post"></i>
                            </span>
                            Getting Started
                        </a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-1-1">Introduction to
                            Angular</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-1-2">Installation &
                            Setup (Angular CLI)</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-1-3">Your First App
                            (Hello World)</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-1-4">Workspace Structure
                            & angular.json</a></li>
                </ul>

                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="index.html#section-2">
                            <span class="theme-icon-holder me-2">
                                <i class="fa fa-signs-post"></i>
                            </span>
                            Components & Templates
                        </a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-2-1">Standalone
                            Components</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-2-2">Component
                            Lifecycle</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-2-3">Template Syntax</a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-2-4">Control Flow (@if,
                            @for, @switch)</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-2-5">Event Binding &
                            Output</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-2-6">Two-Way Binding
                            ([(ngModel)])</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-2-7">Content
                            Projection</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-2-8">View
                            Encapsulation</a></li>
                </ul>

                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="index.html#section-3">
                            <span class="theme-icon-holder me-2">
                                <i class="fa fa-signs-post"></i>
                            </span>
                            Signals & Reactivity
                        </a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-3-1">Angular Signals
                            (Writable & Computed)</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-3-2">Effects</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-3-3">RxJS Interop with
                            Signals</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-3-4">Change Detection
                            Strategy</a></li>
                </ul>

                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="index.html#section-4">
                            <span class="theme-icon-holder me-2">
                                <i class="fa fa-signs-post"></i>
                            </span>
                            Directives & Pipes
                        </a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-4-1">Built-in
                            Directives</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-4-2">Attribute
                            Directives (Custom)</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-4-3">Structural
                            Directives (Custom)</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-4-4">Pipes (Formatting
                            Data)</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-4-5">Creating Custom
                            Pipes</a></li>
                </ul>

                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="index.html#section-5">
                            <span class="theme-icon-holder me-2">
                                <i class="fa fa-signs-post"></i>
                            </span>
                            Dependency Injection (DI)
                        </a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-5-1">Understanding
                            DI</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-5-2">Creating Injectable
                            Services</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-5-3">Hierarchical
                            Injectors</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-5-4">Injection Tokens &
                            Providers</a></li>
                </ul>

                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="index.html#section-6">
                            <span class="theme-icon-holder me-2">
                                <i class="fa fa-signs-post"></i>
                            </span>
                            Routing & Navigation
                        </a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-6-1">Defining Routes</a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-6-2">Router Outlet &
                            Links</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-6-3">Route
                            Parameters</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-6-4">Child Routes</a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-6-5">Lazy Loading
                            Components</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-6-6">Route Guards</a>
                    </li>
                </ul>

                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="index.html#section-7">
                            <span class="theme-icon-holder me-2">
                                <i class="fa fa-signs-post"></i>
                            </span>
                            Forms
                        </a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-7-1">Reactive Forms</a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-7-2">Form Controls &
                            Groups</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-7-3">Form Arrays</a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-7-4">Form Validation</a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-7-5">Template-Driven
                            Forms</a></li>
                </ul>

                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="index.html#section-8">
                            <span class="theme-icon-holder me-2">
                                <i class="fa fa-signs-post"></i>
                            </span>
                            HTTP & Client-Server
                        </a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-8-1">HttpClient
                            Module</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-8-2">Making Requests
                            (GET, POST, etc.)</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-8-3">Http
                            Interceptors</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-8-4">SSR & Hydration</a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-8-5">Static Site
                            Generation (SSG)</a></li>
                </ul>

                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="index.html#section-9">
                            <span class="theme-icon-holder me-2">
                                <i class="fa fa-signs-post"></i>
                            </span>
                            Advanced Topics
                        </a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-9-1">Observables &
                            RxJS</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-9-2">Animations</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-9-3">Internationalization
                            (i18n)</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-9-4">Web Workers</a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-9-5">Angular
                            Elements</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-9-6">Security (XSS)</a>
                    </li>
                </ul>

                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="index.html#section-10">
                            <span class="theme-icon-holder me-2">
                                <i class="fa fa-signs-post"></i>
                            </span>
                            Testing
                        </a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-10-1">Testing Basics</a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-10-2">Component
                            Testing</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-10-3">Service & Pipe
                            Testing</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-10-4">End-to-End
                            Testing</a></li>
                </ul>

                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="index.html#section-11">
                            <span class="theme-icon-holder me-2">
                                <i class="fa fa-signs-post"></i>
                            </span>
                            Tooling & CLI
                        </a>
                    </li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-11-1">Angular CLI
                            Commands Reference</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-11-2">Building for
                            Production</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="index.html#item-11-3">Deployment</a>
                    </li>
                </ul>
            </nav>
        </div>

        <!--//docs-sidebar-->
        <div class="docs-content">
            <div class="container">
                <article class="docs-article" id="section-1">
                    <header class="docs-header">
                        <p class="h2 docs-heading">Section 1: Getting Started</p>
                    </header>
                    <hr>
                    <section class="docs-section" id="item-1-1">
                        <p class="h3">Introduction to Angular</p>
                        <p>Angular is a development platform, built on TypeScript, used for constructing scalable,
                            high-performance web applications. At its core, Angular is a component-based framework that
                            provides a collection of well-integrated libraries covering features such as routing, forms
                            management, and client-server communication. Unlike library-based approaches, Angular
                            provides a holistic ecosystem that dictates a clear architectural pattern, ensuring
                            consistency across large-scale engineering teams.</p>
                        <p>The framework is designed to bridge the gap between document-centric HTML and the
                            requirements of modern web applications. It achieves this through a declarative template
                            syntax that extends HTML, allowing developers to express UI components clearly. Angular
                            manages the complexities of data binding and DOM manipulation, employing an efficient
                            "Change Detection" mechanism that ensures the view stay synchronized with the underlying
                            data model without manual intervention.</p>
                        <p class="h5">Core Architectural Pillars</p>
                        <p>The architecture of an Angular application relies on several fundamental building blocks that
                            work in unison. The most primitive unit is the Component, which encapsulates the HTML
                            template, the TypeScript class containing logic, and the CSS styles. These components are
                            organized into NgModules (or utilized as Standalone Components in modern versions), which
                            provide a compilation context for related files.</p>
                        <p>Angular also enforces a strict separation of concerns through Services. While components
                            handle the user interface and user interaction logic, services are used for data fetching,
                            logging, or business logic that needs to be shared across multiple components. This logic is
                            shared using Dependency Injection (DI), a design pattern where a class requests dependencies
                            from external sources rather than creating them itself.</p>

                        <div class="table-responsive">
                            <table class="table table-hover table-striped align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col" style="width: 20%;">Feature</th>
                                        <th scope="col" style="width: 40%;">Description</th>
                                        <th scope="col" style="width: 40%;">Primary Benefit</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">TypeScript Based</th>
                                        <td>Built on a superset of JavaScript with static typing.</td>
                                        <td>Early error detection and improved IDE tooling.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Two-Way Binding</th>
                                        <td>Synchronization between the Model and the View.</td>
                                        <td>Reduces boilerplate code for form handling.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Dependency Injection</th>
                                        <td>A system for providing objects to a class.</td>
                                        <td>Enhances modularity and simplifies unit testing.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Directives</th>
                                        <td>Attributes that modify DOM elements or behavior.</td>
                                        <td>Enables the creation of reusable UI logic.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Component Structure and Logic</p>
                        <p>Every Angular application has at least one root component that connects the component
                            hierarchy with the page DOM. A component is defined using the <code>@Component</code>
                            decorator, which
                            provides the necessary metadata to the Angular compiler. This metadata informs Angular where
                            to find the HTML template and styles, and what selector to use for the custom element.</p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  standalone: true,
  template: `
    &lt;h1&gt;Welcome to {{ title }}&lt;/h1&gt;
    &lt;p&gt;Angular documentation example.&lt;/p&gt;
  `,
  styles: [`
    h1 { font-family: sans-serif; color: #dd0031; }
  `]
})
export class AppComponent {
  title = 'My Angular Application';
}
</code></pre>

                        <p>In the example above, the <code>{{ title }}</code> syntax represents Interpolation. This
                            allows the
                            framework to dynamically render the value of the <code>title</code> property from the
                            TypeScript class
                            into the HTML. If the value of <code>title</code> changes during the application lifecycle,
                            Angular
                            automatically updates the DOM to reflect the new value.</p>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Starting with Angular 17, the framework introduced a new Block Control Flow syntax
                                    (e.g., <code>@if</code>, <code>@for</code>) which provides a more performant and
                                    readable alternative to
                                    traditional structural directives like <code>*ngIf</code> and <code>*ngFor</code>.
                                </p>
                            </div>
                        </div>
                        <p class="h5">Comparison: Standalone vs. NgModule-based Components</p>
                        <p>Modern Angular development (Version 14+) has shifted toward Standalone Components, which
                            reduce the need for <code>NgModules</code>. This shift simplifies the learning curve and
                            makes the application tree-shakable, meaning the final production bundle only includes the
                            code that is actually used.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Aspect</th>
                                        <th scope="col">Standalone Components</th>
                                        <th scope="col">NgModule-based Components</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Declaration</th>
                                        <td>Declared in the <code>standalone: true</code> flag.</td>
                                        <td>Must be declared in the <code>declarations</code> array of a module.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Dependencies</th>
                                        <td>Imported directly into the component.</td>
                                        <td>Imported into the parent module.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Complexity</th>
                                        <td>Lower; flatter project structure.</td>
                                        <td>Higher; requires managing multiple module files.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Recommended Use</th>
                                        <td>Primary approach for all new applications.</td>
                                        <td>Legacy applications or specific shared library patterns.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">The Compilation Process</p>
                        <p>Angular applications undergo a compilation process called Ahead-of-Time (AOT) compilation.
                            During this phase, the Angular HTML and TypeScript code are converted into efficient
                            JavaScript code before the browser downloads and runs it. Compiling the application during
                            the build process provides faster rendering in the browser because the browser does not need
                            to compile the templates on the fly. This process also detects template errors at build
                            time, preventing runtime crashes.</p>
                        <pre><code class="language-bash"># To build an Angular application with AOT enabled (default in production)
ng build --configuration production
</code></pre>
                        <p>When you execute this command, the Angular CLI utilizes the TypeScript compiler and the
                            Angular template compiler to minify code, perform "Tree Shaking" (removing unused code), and
                            generate highly optimized bundles.
                        </p>
                        <p>Warning: Never use <code>angular.js</code> (Angular 1.x) documentation for modern Angular
                            (v2+). Modern
                            Angular is a complete rewrite and is not backward compatible with the original AngularJS
                            framework.</p>

                    </section>
                    <section class="docs-section" id="item-1-2">
                        <p class="h3">Installation & Setup (Angular CLI)</p>
                        <p>The Angular Command Line Interface (CLI) is the fundamental tool for initializing,
                            developing, scaffolding, and maintaining Angular applications directly from a command shell.
                            It abstracts the complex build configurations—such as Webpack or Esbuild, TypeScript
                            compilation, and SCSS processing—allowing developers to focus on application logic rather
                            than build-tool orchestration. The CLI ensures that every project adheres to the recommended
                            folder structure and architectural best practices defined by the Angular team.</p>
                        <p>To utilize the Angular CLI, your development environment must have Node.js and npm (Node
                            Package Manager) installed. Node.js acts as the runtime environment for the CLI's build
                            tools, while npm manages the framework's extensive library dependencies. Angular typically
                            requires an Active LTS (Long Term Support) or Current version of Node.js.</p>
                        <p class="h5">Prerequisites and Version Compatibility</p>
                        <p>Before installing the CLI, it is critical to verify that your environment meets the minimum
                            version requirements. Discrepancies between Node.js versions and Angular versions can lead
                            to compilation errors or failures in the underlying BuildKit.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Requirement</th>
                                        <th scope="col">Minimum Version (Angular 17/18/19)</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Node.js</th>
                                        <td>v18.19.1 or v20.11.1+</td>
                                        <td>JavaScript runtime for development tools.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">npm</th>
                                        <td>v9.0.0+</td>
                                        <td>Package manager for fetching Angular modules.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">OS</th>
                                        <td>Windows, macOS, or Linux</td>
                                        <td>Cross-platform development support.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Global Installation of Angular CLI</p>
                        <p>The Angular CLI is installed globally on your system using the <code>npm install</code>
                            command with the
                            <code>-g</code> flag. This allows you to run the <code>ng</code> command from any directory
                            on your machine.
                        </p>

                        <pre><code class="language-bash"># Install the Angular CLI globally
npm install -g @angular/cli

# Verify the installation and check the version
ng version
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>If you are on a macOS or Linux system and encounter "EACCES" permissions errors
                                    during global installation, it is recommended to use a version manager like nvm
                                    (Node Version Manager) rather than prefixing commands with <code>sudo</code>, which
                                    can lead to file ownership issues later.</p>
                            </div>
                        </div>

                        <p class="h5">Initializing a New Project</p>
                        <p>To create a new workspace, you use the <code>ng new</code> command followed by your desired
                            project name. This command initiates an interactive prompt that configures the initial state
                            of your application. You will be asked to choose a stylesheet format (such as CSS, SCSS, or
                            Sass) and whether you wish to enable Server-Side Rendering (SSR) and Static Site Generation
                            (SSG).</p>
                        <pre><code class="language-bash"># Create a new project named 'my-tech-docs'
ng new my-tech-docs
</code></pre>
                        <p class="h5">When this command runs, the CLI performs several automated tasks:</p>
                        <ol>
                            <li>Creates a new directory named <code>my-tech-docs</code>.</li>
                            <li>Generates the workspace configuration files and a default skeletal application.</li>
                            <li>Installs all necessary npm packages (dependencies) listed in <code>package.json</code>.
                            </li>
                            <li>Initializes a Git repository and performs an initial commit.</li>
                        </ol>
                        <p class="h5">Project Configuration Options</p>
                        <p>The <code>ng new</code> command supports various flags to bypass interactive prompts or
                            enforce specific architectural choices. These are useful for CI/CD pipelines or standardized
                            team environments.</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Flag</th>
                                        <th scope="col">Type</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>--style</code></td>
                                        <td>string</td>
                                        <td>The file extension or preprocessor to use for styles (css, scss, sass,
                                            less).</td>
                                    </tr>
                                    <tr>
                                        <td><code>--routing</code></td>
                                        <td>boolean</td>
                                        <td>Generates a routing module for the application (default is true in newer
                                            versions).</td>
                                    </tr>
                                    <tr>
                                        <td><code>--strict</code></td>
                                        <td>boolean</td>
                                        <td>Enables strict type checking and bundle size budgets.</td>
                                    </tr>
                                    <tr>
                                        <td><code>--skip-install</code></td>
                                        <td>boolean</td>
                                        <td>Skips the <code>npm install</code> step; allows manual dependency
                                            resolution.</td>
                                    </tr>
                                    <tr>
                                        <td><code>--prefix</code></td>
                                        <td>string</td>
                                        <td>The prefix to use for generated component selectors (default is
                                            <code>app</code>).
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Running the Development Server</p>
                        <p>Once the project is initialized, the CLI provides a built-in development server. By executing
                            the <code>ng serve</code> command, the CLI compiles the application in memory, starts a
                            local web server (usually at <code>http://localhost:4200</code>), and watches the source
                            files for changes.
                        </p>
                        <pre><code class="language-bash"># Navigate into the project folder
cd my-tech-docs

# Launch the development server and open it in your default browser
ng serve --open
                        </code></pre>
                        <p>The <code>--open</code> (or <code>-o</code>) flag automatically launches your browser to the
                            correct local URL. Because the CLI utilizes Hot Module Replacement (HMR), any changes you
                            save in your TypeScript, HTML, or CSS files will trigger an instantaneous partial reload of
                            the application in the browser, maintaining the current state of the UI.
                        </p>
                        <p>Warning: The development server provided by <code>ng serve</code> is intended solely for
                            local development. It is not optimized for security or performance in a production
                            environment. Always use <code>ng build</code> to generate production-ready assets for
                            deployment to a web server.
                        </p>

                    </section>
                    <section class="docs-section" id="item-1-3">
                        <p class="h3">Your First App (Hello World)</p>
                        <p>Creating a "Hello World" application in Angular involves understanding the flow of data from
                            a TypeScript class to an HTML template. In modern Angular (version 17+), this is typically
                            achieved using Standalone Components, which eliminate the need for complex internal module
                            declarations. A "Hello World" app demonstrates the core power of Angular: Interpolation,
                            where a component's property is dynamically rendered into the view.
                        </p>
                        <p>The process begins in the <code>app.component.ts</code> file, which serves as the entry point
                            for your application's UI. This file contains the logic (the Class), the structure (the
                            Template), and the styling (the CSS). By defining a property in the class, you make it
                            available to the template for rendering.
                        </p>
                        <p class="h5">Anatomy of the Hello World Component</p>
                        <p>A component is defined using the <code>@Component</code> decorator. This decorator attaches
                            metadata to a
                            standard TypeScript class, telling Angular how that class should behave. The
                            <code>selector</code>
                            property defines the custom HTML tag (e.g., <code>&lt;app-root&gt;</code>) that represents the
                            component, while
                            the <code>template</code> property contains the HTML structure.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  standalone: true,
  template: `
    &lt;div class="container"&gt;
      &lt;h1&gt;{{ title }}&lt;/h1&gt;
      &lt;p&gt;Status: {{ message }}&lt;/p&gt;
      &lt;button (click)="updateMessage()"&gt;Click Me&lt;/button&gt;
    &lt;/div&gt;
  `,
  styles: [`
    .container { text-align: center; margin-top: 50px; }
    h1 { color: #c3002f; }
  `]
})
export class AppComponent {
  title = 'Hello World!';
  message = 'Welcome to your first Angular app.';

  updateMessage() {
    this.message = 'You successfully interacted with the component!';
  }
}
</code></pre>
                        <p>In the code above, <code>{{ title }}</code> and <code>{{ message }}</code> are examples of
                            Text Interpolation. This is a one-way data binding mechanism where the value flows from the
                            TypeScript class to the HTML. The <code>(click)</code> syntax represents Event Binding,
                            which allows the HTML to trigger logic defined in the TypeScript class.
                        </p>
                        <p class="h5">Key Building Blocks of the Component</p>
                        <p>To understand how this "Hello World" app functions, you must recognize the role of each
                            property within the <code>@Component</code> metadata and the class body.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Metadata/Property</th>
                                        <th scope="col">Type</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>selector</code></td>
                                        <td>String</td>
                                        <td>The CSS selector that identifies this component in a template (usually
                                            <code>app-root</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>standalone</code></td>
                                        <td>Boolean</td>
                                        <td>If <code>true</code>, the component does not require an
                                            <code>NgModule</code> to function.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>template</code></td>
                                        <td>String</td>
                                        <td>The HTML markup that defines the component's visual appearance.</td>
                                    </tr>
                                    <tr>
                                        <td><code>styles</code></td>
                                        <td>Array</td>
                                        <td>CSS styles scoped specifically to this component.</td>
                                    </tr>
                                    <tr>
                                        <td><code>Class Body</code></td>
                                        <td>Logic</td>
                                        <td>Contains the properties (data) and methods (behavior) of the component.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <p class="h5">Bootstrapping the Application</p>
                        <p>For the "Hello World" component to appear in the browser, it must be "bootstrapped."
                            Bootstrapping is the process Angular uses to initialize the application and render the root
                            component into the <code>index.html</code> file. In a standalone application, this occurs in
                            the <code>main.ts</code> file using the <code>bootstrapApplication</code> function.
                        </p>
                        <pre><code class="language-javascript">
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent)
  .catch((err) =&gt; console.error(err));</code></pre>
                        <p>The <code>index.html</code> file contains a placeholder tag that matches the
                            <code>selector</code> defined in your component. When the application starts, Angular
                            replaces <code>&lt;app-root&gt;&lt;/app-root&gt;</code> with the rendered HTML from your
                            <code>AppComponent</code>.
                        </p>
                        <pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;HelloWorldApp&lt;/title&gt;
  &lt;base href="/"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;app-root&gt;&lt;/app-root&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Angular uses Scoped Styling by default. This means the CSS defined in the
                                    <code>styles</code>
                                    array of <code>app.component.ts</code> will only affect the elements within that
                                    specific
                                    component. It will not leak out and affect other components or the global
                                    <code>index.html</code>
                                    structure.
                                </p>
                            </div>
                        </div>
                        <p class="h5">Step-by-Step Execution Flow</p>
                        <p>To see your "Hello World" application in action, follow these command-line steps to
                            initialize and view the project.
                        </p>
                        <ol>
                            <li>Generate the App: Run <code>ng new hello-world</code> and follow the prompts to select
                                your style preferences.</li>
                            <li>Navigate and Serve: Move into the project directory and start the local server.</li>
                            <li>Modify Code: Open <code>src/app/app.component.ts</code> and replace the boilerplate with
                                the "Hello World" logic shown above.</li>
                            <li>Observe Auto-Reload: Save the file; the CLI will automatically recompile and refresh
                                your browser.</li>
                        </ol>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Command</th>
                                        <th scope="col">Action</th>
                                        <th scope="col">Result</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>ng new hello-world</code></td>
                                        <td>Initialization</td>
                                        <td>Creates folder structure and installs dependencies.</td>
                                    </tr>
                                    <tr>
                                        <td><code>ng serve</code></td>
                                        <td>Execution</td>
                                        <td>Compiles the app and hosts it at <code>localhost:4200</code>.</td>
                                    </tr>
                                    <tr>
                                        <td><code>ng generate component</code></td>
                                        <td>Scaffolding</td>
                                        <td>Creates a new component folder with TS, HTML, and CSS files.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p>Warning: If you are using an older project (Angular 14 or below), your "Hello World" might
                            still be wrapped in an <code>app.module.ts</code> file. While Standalone Components are the
                            new standard,
                            ensure you check for the presence of the <code>standalone: true</code> flag before
                            attempting to
                            bootstrap without a module.
                        </p>

                    </section>
                    <section class="docs-section" id="item-1-4">
                        <p class="h3">Workspace Structure & angular.json</p>
                        <p>An Angular workspace is a collection of projects (applications and libraries) that share a
                            common configuration. When you initialize a project using the Angular CLI, it generates a
                            standardized directory structure designed for scalability and maintainability. Understanding
                            this structure is essential for navigating the codebase and managing how the application is
                            built, tested, and deployed.</p>
                        <p>At the heart of this workspace is the <code>angular.json</code> file, which serves as the
                            "source of truth" for the entire project's configuration. It dictates how the CLI interacts
                            with your source code, defining everything from the entry point of the application to the
                            specific optimization techniques used during the production build.</p>
                        <p class="h5">The Root Workspace Directory</p>
                        <p>The root of an Angular project contains configuration files for the development environment,
                            build tools, and dependency management. While your primary logic resides in the
                            <code>src/</code> folder, these root files govern how that logic is processed.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">File/Folder</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><code>node_modules/</code></th>
                                        <td>Contains the npm packages (dependencies) required by the workspace.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>src/</code></th>
                                        <td>The source files for the application (components, assets, styles).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>angular.json</code></th>
                                        <td>CLI configuration for build, serve, and test tools.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>package.json</code></th>
                                        <td>Lists npm package dependencies and scripts.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>tsconfig.json</code></th>
                                        <td>TypeScript compiler configuration for the workspace.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>.editorconfig</code></th>
                                        <td>Configuration for code editors to maintain consistent coding styles.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">The src/ Folder Anatomy</p>
                        <p>The <code>src/</code> folder is where the actual application development happens. It contains
                            the logic, templates, and static assets that will eventually be compiled into the final
                            JavaScript bundle.</p>
                        <ul>
                            <li>app/: Contains the component logic and templates. In a standalone application, this is
                                where your root <code>app.component.ts</code> and other functional components reside.
                            </li>
                            <li>assets/: A folder for static files like images, icons, and localization files that
                                should be copied directly to the build output without processing.</li>
                            <li>index.html: The main HTML page that serves as the foundation for the single-page
                                application (SPA).</li>
                            <li>main.ts: The main entry point for the application. This file bootstraps the root
                                component to start the app.</li>
                            <li>styles.css: The global stylesheet for the entire application.</li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Files located in the <code>assets/</code> folder are not processed by the Angular
                                    compiler or
                                    Webpack/Esbuild. If you need to reference a file that requires processing (like an
                                    SCSS file), it should be placed outside of <code>assets/</code> and imported into
                                    your styles or
                                    components.</p>
                            </div>
                        </div>
                        <p class="h5">Understanding angular.json</p>
                        <p>The <code>angular.json</code> file provides workspace-wide and project-specific configuration
                            defaults for
                            build and development tools. It is organized into a hierarchy where the
                            <code>projects</code> object
                            contains the settings for each individual application or library in the workspace.
                        </p>
                        <pre><code class="language-json">{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "my-app": {
      "projectType": "application",
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:browser",
          "options": {
            "outputPath": "dist/my-app",
            "index": "src/index.html",
            "main": "src/main.ts",
            "assets": ["src/favicon.ico", "src/assets"],
            "styles": ["src/styles.css"],
            "scripts": []
          },
          "configurations": {
            "production": {
              "optimization": true,
              "outputHashing": "all",
              "sourceMap": false
            }
          }
        }
      }
    }
  }
}
</code></pre>
                        <p>The <code>architect</code> section is the most critical part of this file. It defines
                            "targets" such as
                            <code>build</code>, <code>serve</code>, and <code>test</code>. Each target specifies a
                            "builder"—an external tool that performs the
                            action—and a set of default options.
                        </p>
                        <p class="h5">Configuration Options in angular.json</p>
                        <p>The following table explains the most common configuration options found under the build
                            target in <code>angular.json</code>.</p>

                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Option</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">outputPath</th>
                                        <td>The directory where the build files will be placed (usually
                                            <code>dist/</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row">index</th>
                                        <td>The path to the HTML file that serves as the application shell.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">main</th>
                                        <td>The path to the TypeScript entry point for the application.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">assets</th>
                                        <td>An array of files or folders to be copied to the output directory.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">styles</th>
                                        <td>Global CSS files to be included in the build.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">optimization</th>
                                        <td>Enables scripts/styles minification and tree-shaking (default for
                                            production).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">outputHashing</th>
                                        <td>Appends a unique hash to filenames to break browser caching after updates.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Build Configurations (Development vs. Production)</p>
                        <p>Angular allows you to define different configurations for different environments within
                            <code>angular.json</code>. For example, the <code>production</code> configuration typically
                            enables strict
                            optimization, removes source maps for smaller bundle sizes, and uses file hashing. You can
                            trigger these configurations by passing the <code>--configuration</code> flag to the CLI.
                        </p>
                        <pre><code class="language-bash"># Build using the 'production' configuration defined in angular.json
ng build --configuration production
</code></pre>
                        <p>When you run <code>ng serve</code>, the CLI actually references the <code>serve</code> target
                            in <code>angular.json</code>, which by
                            default uses the <code>development</code> configuration of the <code>build</code> target to
                            ensure fast incremental rebuilds.</p>
                        <p>Warning: Manually editing <code>angular.json</code> requires caution. A syntax error or an
                            incorrect path in this file can prevent the Angular CLI from starting the server or building
                            the
                            application. Always verify the file structure after moving or renaming core files like
                            <code>main.ts</code> or <code>index.html</code>.
                        </p>
                    </section>
                </article>


                <article class="docs-article" id="section-2">
                    <header class="docs-header">
                        <p class="h2 docs-heading">Section 2: Components & Templates</p>
                    </header>
                    <hr>
                    <section class="docs-section" id="item-2-1">
                        <p class="h3">Standalone Components (The Modern Standard)</p>
                        <p>Starting with Angular 14 and becoming the default in Angular 17, Standalone Components
                            represent the modern architectural standard for Angular applications. Traditionally, every
                            component had to belong to an <code>NgModule</code>, which acted as a container for
                            declarations and
                            dependencies. Standalone components eliminate this requirement by allowing components to
                            manage their own dependencies directly. This "component-first" approach simplifies the
                            mental model, reduces boilerplate, and makes the application more "tree-shakable," ensuring
                            only necessary code is included in the final production bundle.
                        </p>
                        <p>A standalone component is defined by setting the <code>standalone: true</code> flag within
                            the <code>@Component</code>
                            decorator. Because it is no longer part of a module, the component must explicitly list any
                            other components, directives, or pipes it uses in its own <code>imports</code> array. This
                            makes the
                            component a self-contained unit that is easier to move, test, and reuse across different
                            parts of an application.
                        </p>
                        <p class="h5">Anatomy of a Standalone Component</p>
                        <p>The structure of a standalone component integrates what used to be handled by
                            <code>app.module.ts</code>
                            directly into the component's metadata. This consolidation creates a clear, traceable link
                            between the UI and its required logic.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { UserProfileComponent } from './user-profile/user-profile.component';

@Component({
  selector: 'app-dashboard',
  standalone: true,
  imports: [
    CommonModule,          // Provides standard directives like ngIf and ngFor
    UserProfileComponent   // Importing another standalone component directly
  ],
  template: `
    &lt;section class="dashboard"&gt;
      &lt;h1&gt;User Dashboard&lt;/h1&gt;
      &lt;app-user-profile [userId]="currentUserId"&gt;&lt;/app-user-profile&gt;
      
      @if (isLoggedIn) {
        &lt;p&gt;Welcome back, Admin!&lt;/p&gt;
      }
    &lt;/section&gt;
  `,
  styles: [`
    .dashboard { padding: 20px; background: #f4f4f4; }
  `]
})
export class DashboardComponent {
  currentUserId = 101;
  isLoggedIn = true;
}
</code></pre>
                        <p>In the example above, the <code>DashboardComponent</code> is entirely self-sufficient. It
                            imports
                            <code>CommonModule</code> to gain access to standard Angular features and specifically
                            imports
                            <code>UserProfileComponent</code> to use it within its template.
                        </p>
                        <p class="h5">Comparison: Standalone vs. Module-Based</p>
                        <p>Transitioning to standalone components changes how dependencies are resolved and how the
                            application starts up. The following table highlights the key differences in development
                            workflow.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Standalone Components</th>
                                        <th scope="col">NgModule-Based Components</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Declaration</th>
                                        <td><code>standalone: true</code> in decorator.</td>
                                        <td>Added to <code>declarations: []</code> in a module.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Dependency Management</th>
                                        <td><code>imports: []</code> inside the component.</td>
                                        <td><code>imports: []</code> inside the parent module.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Bootstrapping</th>
                                        <td><code>bootstrapApplication(RootComponent)</code></td>
                                        <td><code>platformBrowserDynamic().bootstrapModule(AppModule)</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Visibility</th>
                                        <td>Public by default to anyone importing it.</td>
                                        <td>Only visible to other components in the same module unless exported.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Lazy Loading</th>
                                        <td>Load the component directly in routes.</td>
                                        <td>Must load the module that contains the component.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Even in a standalone application, you can still use existing libraries that are
                                    module-based. You simply include the <code>NgModule</code> (like
                                    <code>ReactiveFormsModule</code> or
                                    <code>HttpClientModule</code>) in the <code>imports</code> array of your standalone
                                    component.
                                </p>
                            </div>
                        </div>
                        <p class="h5">Bootstrapping a Standalone Application</p>
                        <p>In a standalone-first project, the <code>main.ts</code> file undergoes a significant change.
                            Instead of
                            pointing to an <code>AppModule</code>, it initializes the application by pointing directly
                            to the root
                            component. This process often includes the <code>provideRouter</code> and
                            <code>provideHttpClient</code> functions to
                            set up global services that were previously configured in modules.
                        </p>
                        <pre><code class="language-javascript">import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter } from '@angular/router';
import { AppComponent } from './app/app.component';
import { routes } from './app/app.routes';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes) // Global routing configuration
  ]
}).catch(err =&gt; console.error(err));
</code></pre>
                        <p class="h5">Dependency Resolution and Edge Cases</p>
                        <p>When using standalone components, Angular uses a hierarchical injector system similar to the
                            one used with modules. However, because components are imported directly, the "compilation
                            context" is more localized. One edge case involves Circular Dependencies: if Component A
                            imports Component B, and Component B imports Component A, the compiler will throw an error.
                            This is usually a sign that common logic should be extracted into a shared Service or a
                            third, shared Standalone Component.
                        </p>
                        <p>
                            Warning: Do not mix <code>standalone: true</code> with the <code>declarations</code> array
                            of an <code>NgModule</code>. A standalone component cannot be "declared" in a module; it can
                            only be "imported" by a module or another standalone component. Attempting to declare a
                            standalone component will result in
                            a template compiler error.
                        </p>

                    </section>
                    <section class="docs-section" id="item-2-2">
                        <p class="h3">Component Lifecycle</p>
                        <p>An Angular component has a lifecycle managed by the framework, which starts when Angular
                            instantiates the component class and renders the component view along with its child views.
                            The lifecycle continues as Angular checks when data-bound properties change and eventually
                            ends when Angular destroys the component instance and removes its rendered template from the
                            DOM.
                        </p>
                        <p>To tap into these key moments, Angular provides Lifecycle Hooks. These are specific
                            interfaces that, when implemented by a component class, allow you to execute logic at
                            precise intervals. Understanding these hooks is vital for tasks such as fetching data from a
                            server, initializing third-party libraries, or cleaning up resources to prevent memory
                            leaks.
                        </p>
                        <p class="h5">The Lifecycle Sequence</p>
                        <p>Angular executes lifecycle hooks in a specific order. They are divided into those that run
                            during the initial check and those that run during every subsequent change detection cycle.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Hook</th>
                                        <th scope="col">Timing</th>
                                        <th scope="col">Use Case</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>ngOnChanges</strong></td>
                                        <td>Before <code>ngOnInit</code> and when an <code>@Input</code> property
                                            changes.</td>
                                        <td>Acting upon changes to input data from a parent.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>ngOnInit</strong></td>
                                        <td>Once, after the first <code>ngOnChanges</code>.</td>
                                        <td>Initializing data or fetching from services.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>ngDoCheck</strong></td>
                                        <td>During every change detection run.</td>
                                        <td>Custom change detection for complex logic.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>ngAfterViewInit</strong></td>
                                        <td>Once, after the component's view is initialized.</td>
                                        <td>Accessing DOM elements via <code>@ViewChild</code>.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>ngOnDestroy</strong></td>
                                        <td>Just before the component is destroyed.</td>
                                        <td>Unsubscribing from Observables or clearing timers.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Implementing Lifecycle Hooks</p>
                        <p>To use a lifecycle hook, you must import the interface from <code>@angular/core</code> and
                            implement the corresponding method within your class. While not strictly required by the
                            compiler for the logic to work, implementing the interface is a best practice for TypeScript
                            type safety.
                        </p>
                        <pre><code class="language-javascript">import { 
  Component, 
  OnInit, 
  OnChanges, 
  OnDestroy, 
  SimpleChanges, 
  Input 
} from '@angular/core';
import { Subscription, interval } from 'rxjs';

@Component({
  selector: 'app-lifecycle-demo',
  standalone: true,
  template: `
    &lt;div class="box"&gt;
      &lt;h3&gt;Counter: {{ count }}&lt;/h3&gt;
      &lt;p&gt;External ID: {{ externalId }}&lt;/p&gt;
    &lt;/div&gt;
  `
})
export class LifecycleDemoComponent implements OnInit, OnChanges, OnDestroy {
  @Input() externalId!: string;
  count = 0;
  private timerSubscription?: Subscription;

  constructor() {
    // 1. Constructor: Logic here should be minimal. 
    // Inputs are NOT yet available.
    console.log('Constructor: Component instance created.');
  }

  ngOnChanges(changes: SimpleChanges) {
    // 2. ngOnChanges: Triggered when @Input properties change.
    if (changes['externalId']) {
      console.log('ID changed from:', changes['externalId'].previousValue);
    }
  }

  ngOnInit() {
    // 3. ngOnInit: Triggered once. Inputs are now available.
    console.log('ngOnInit: Component initialized.');
    this.timerSubscription = interval(1000).subscribe(() =&gt; this.count++);
  }

  ngOnDestroy() {
    // 4. ngOnDestroy: Cleanup to prevent memory leaks.
    console.log('ngOnDestroy: Cleaning up resources.');
    this.timerSubscription?.unsubscribe();
  }
}
</code></pre>
                        <p class="h5">Deep Dive: ngOnChanges vs. ngOnInit</p>
                        <p>One of the most common points of confusion is when to use <code>ngOnChanges</code> versus
                            <code>ngOnInit</code>. The
                            <code>ngOnChanges</code> hook is the only hook that receives an argument: the
                            <code>SimpleChanges</code> object. This
                            object contains the current and previous values of every <code>@Input</code> property.
                        </p>
                        <p>If your component logic depends on data being passed in from a parent component, and that
                            data might change over time, you must use <code>ngOnChanges</code>. If you only need to run
                            a task once
                            when the component is first loaded (like a single API call), <code>ngOnInit</code> is the
                            appropriate
                            choice.
                        </p>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>The <code>constructor</code> is a standard TypeScript feature and is called before
                                    Angular begins
                                    its lifecycle. You should avoid putting complex logic in the constructor. Use
                                    <code>ngOnInit</code> for any initialization that requires Angular-specific features
                                    like Inputs
                                    or Services.
                                </p>
                            </div>
                        </div>
                        <p class="h5">View Initialization Hooks</p>
                        <p>In addition to data-related hooks, Angular provides hooks for when the UI is fully rendered.
                            <code>ngAfterViewInit</code> is particularly important when you need to interact with the
                            DOM or child
                            components using <code>@ViewChild</code>.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">View Hook</th>
                                        <th scope="col">Execution</th>
                                        <th scope="col">Primary Limitation</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><code>ngAfterContentInit</code></th>
                                        <td>After external content is projected into the component.</td>
                                        <td>Only for <code>&lt;ng-content&gt;</code> scenarios.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>ngAfterViewInit</code></th>
                                        <td>After the component's template and child views are ready.</td>
                                        <td>Modifying data here may trigger
                                            "ExpressionChangedAfterItHasBeenCheckedError".</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript>">import { Component, AfterViewInit, ViewChild, ElementRef } from '@angular/core';

@Component({
  selector: 'app-dom-ref',
  standalone: true,
  template: `&lt;input #myInput type="text"&gt;`
})
export class DomRefComponent implements AfterViewInit {
  @ViewChild('myInput') inputElement!: ElementRef;

  ngAfterViewInit() {
    // You cannot access inputElement safely in ngOnInit 
    // because the view isn't rendered yet.
    this.inputElement.nativeElement.focus();
  }
}
</code></pre>
                        <p>Warning: Always unsubscribe from long-lived Observables (like those from
                            <code>interval</code> or custom
                            <code>Subject</code> instances) in the <code>ngOnDestroy</code> hook. Failing to do so can
                            cause memory leaks, as the
                            subscription will continue to live even after the component is removed from the DOM.
                        </p>

                    </section>
                    <section class="docs-section" id="item-2-3">
                        <p class="h3">Template Syntax (Interpolation, Property Binding)</p>
                        <p>In Angular, the template is the blueprint for the user interface. Template syntax allows you
                            to coordinate between the logic in your TypeScript class and the presentation in your HTML.
                            Rather than manually manipulating the DOM to update values, you use declarative bindings.
                            This means you describe the relationship between your data and the UI, and Angular
                            automatically handles the updates when the data state changes.
                        </p>
                        <p>The two most fundamental ways to move data from your component logic to the view are
                            Interpolation and Property Binding. While they often achieve similar visual results, they
                            serve different technical purposes and have distinct syntax rules.
                        </p>
                        <p class="h5">Text Interpolation</p>
                        <p>Interpolation refers to embedding expressions into marked-up text. By default, interpolation
                            uses the double curly braces {{ and }} as delimiters. Angular replaces the expression within
                            the braces with the string value of the corresponding component property.
                        </p>
                        <p>Angular evaluates the expression within the braces, converts the result to a string, and
                            integrates it into the HTML. It is important to note that interpolation is for content, not
                            for HTML attributes that require non-string data types.
                        </p>

                        <pre><code class="language-javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-interpolation-demo',
  standalone: true,
  template: `
    &lt;div class="card"&gt;
      &lt;h2&gt;User: {{ username }}&lt;/h2&gt;
      &lt;p&gt;Account Balance: {{ balance * conversionRate | currency }}&lt;/p&gt;
      &lt;p&gt;Status: {{ getStatusMessage() }}&lt;/p&gt;
    &lt;/div&gt;
  `
})
export class InterpolationComponent {
  username = 'Alice';
  balance = 150.50;
  conversionRate = 0.92;

  getStatusMessage() {
    return this.balance &gt; 0 ? 'Active' : 'Pending';
  }
}
</code></pre>
                        <p class="h5">Property Binding</p>
                        <p>Property binding allows you to set the property of an element or directive to the value of a
                            template expression. Unlike interpolation, which is always converted to a string, property
                            binding can pass any data type (objects, booleans, or arrays) to the target property. The
                            syntax involves wrapping the target property name in square brackets <code>[]</code>.
                        </p>
                        <p>Property binding is essential when you want to control the state of an element, such as
                            disabling a button, setting a source for an image, or passing data into a child component's
                            <code>@Input</code>.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-property-binding',
  standalone: true,
  template: `
    &lt;button [disabled]="isFormInvalid"&gt;Submit&lt;/button&gt;

    &lt;img [src]="profileImageUrl" [alt]="username + ' profile picture'"&gt;

    &lt;div [class.active-row]="isActive"&gt;Row Data&lt;/div&gt;
  `
})
export class PropertyBindingComponent {
  isFormInvalid = true;
  profileImageUrl = 'assets/images/user-01.png';
  username = 'Alice';
  isActive = false;
}
</code></pre>
                        <p class="h5">Technical Comparison</p>
                        <p>Choosing between interpolation and property binding often depends on whether you are
                            modifying the text content inside an element or an attribute/property of the element itself.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Interpolation</th>
                                        <th scope="col">Property Binding</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Syntax</th>
                                        <td><code>{{ expression }}</code></td>
                                        <td><code>[target]="expression"</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Target</th>
                                        <td>Element content (text).</td>
                                        <td>Element properties, component inputs, or attribute directives.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Data Type</th>
                                        <td>Always converted to a <code>string</code>.</td>
                                        <td>Preserves original data types (boolean, object, etc.).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Use Case</th>
                                        <td>Displaying dynamic text in headings or paragraphs.</td>
                                        <td>Controlling logic (e.g., <code>disabled</code>, <code>hidden</code>) or
                                            passing data objects.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Security and Sanitization</p>
                        <p>Angular provides built-in protections against malicious attacks. For both interpolation and
                            property binding, Angular sanitizes the values before rendering them. This prevents
                            Cross-Site Scripting (XSS) by neutralizing potentially dangerous HTML or script tags.
                        </p>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Angular does not support script tags in templates. Any <code>&lt;script&gt;</code>
                                    tag included in
                                    an interpolation or property binding will be ignored or stripped for security
                                    reasons. If you must render trusted HTML, you must use the <code>[innerHTML]</code>
                                    property
                                    binding and explicitly trust the value using Angular's <code>DomSanitizer</code>
                                    service.</p>
                            </div>
                        </div>
                        <p class="h5">Common Pitfalls and Edge Cases</p>
                        <p>When using property binding, it is a common mistake to confuse attributes with properties. An
                            attribute is defined by the HTML, while a property is defined by the DOM. Angular binding
                            works almost exclusively with DOM properties.
                        </p>
                        <ul>
                            <li>Attribute Binding: Used for items that do not have a corresponding DOM property, such as
                                <code>colspan</code> or <code>aria</code> labels. Use the syntax
                                <code>[attr.name]</code>.
                            </li>
                            <li>Class and Style Binding: Specialized versions of property binding for manipulating CSS.
                                Use <code>[class.name]</code> or <code>[style.width]</code>.
                            </li>
                        </ul>
                        <pre><code class="language-javascript">@Component({
  selector: 'app-special-bindings',
  standalone: true,
  template: `
    &lt;td [attr.colspan]="1 + 1"&gt;Two Columns&lt;/td&gt;

    &lt;div [style.color]="isError ? 'red' : 'green'"&gt;Status Message&lt;/div&gt;
  `
})
export class SpecialBindingsComponent {
  isError = true;
}
</code></pre>
                        <p>Warning: Avoid side effects in your template expressions. A template expression should not
                            change the state of the application; it should only return a value. For example, calling a
                            function that increments a counter inside <code>{{ }}</code> will lead to unstable change
                            detection and
                            performance issues.
                        </p>
                    </section>

                    <section class="docs-section" id="item-2-4">
                        <p class="h3">Control Flow (@if, @for, @switch)</p>
                        <p>In modern Angular (v17+), the framework introduced a new, built-in Block Control Flow syntax.
                            This syntax replaces the legacy structural directives (<code>*ngIf</code>,
                            <code>*ngFor</code>, and <code>*ngSwitch</code>) with a
                            more performant, readable, and developer-friendly approach. Built directly into the Angular
                            compiler, this new syntax reduces the need for importing <code>CommonModule</code> and
                            offers
                            significantly better type-checking within your templates.
                        </p>
                        <p>The new control flow uses a "at-symbol" (<code>@</code>) prefix followed by the control
                            keyword. This
                            allows for a clean separation between standard HTML attributes and logical control
                            structures, making the code resemble standard JavaScript or TypeScript logic more closely.
                        </p>
                        <p class="h5">Conditional Logic with @if</p>
                        <p>The <code>@if</code> block allows you to conditionally render a portion of the UI. Unlike the
                            older <code>*ngIf</code>,
                            the new syntax supports <code>@else if</code> and <code>@else</code> blocks natively without
                            the need for complex
                            <code>ng-template</code> references.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-auth-display',
  standalone: true,
  template: `
    &lt;div class="auth-container"&gt;
      @if (userStatus === 'admin') {
        &lt;p&gt;Welcome, Administrator. Access granted to all systems.&lt;/p&gt;
        &lt;button&gt;Open Dashboard&lt;/button&gt;
      } @else if (userStatus === 'user') {
        &lt;p&gt;Welcome back, user! Check your profile.&lt;/p&gt;
      } @else {
        &lt;p&gt;Access Denied. Please log in.&lt;/p&gt;
        &lt;button (click)="login()"&gt;Login&lt;/button&gt;
      }
    &lt;/div&gt;
  `
})
export class AuthDisplayComponent {
  userStatus: 'admin' | 'user' | 'guest' = 'guest';

  login() {
    this.userStatus = 'user';
  }
}
</code></pre>
                        <p class="h5">Iteration with @for</p>
                        <p>The <code>@for</code> block is used to render a list of items. A significant improvement in
                            the new syntax
                            is the mandatory <code>track</code> expression. Tracking improves rendering performance by
                            helping
                            Angular identify which items in a collection have changed, been added, or removed.
                        </p>
                        <p>Additionally, the <code>@for</code> block includes a built-in <code>@empty</code> block,
                            which displays content
                            automatically when the collection being iterated is empty or null, eliminating the need for
                            a separate <code>@if</code> check.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Property</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><code>track</code></th>
                                        <td><strong>(Mandatory)</strong> A unique identifier for each item (e.g.,
                                            <code>item.id</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>$index</code></th>
                                        <td>The index of the current row in the collection.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>$count</code></th>
                                        <td>The total number of items in the collection.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>$first / $last</code></th>
                                        <td>Booleans indicating if the item is the first or last in the list.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>$even / $odd</code></th>
                                        <td>Booleans indicating the parity of the current index.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-product-list',
  standalone: true,
  template: `
    &lt;ul&gt;
      @for (product of products; track product.id; let i = $index) {
        &lt;li&gt;
          {{ i + 1 }}. {{ product.name }} - {{ product.price | currency }}
          @if ($first) { &lt;span class="badge"&gt;Newest!&lt;/span&gt; }
        &lt;/li&gt;
      } @empty {
        &lt;li&gt;No products available at this time.&lt;/li&gt;
      }
    &lt;/ul&gt;
  `
})
export class ProductListComponent {
  products = [
    { id: 101, name: 'Laptop', price: 1200 },
    { id: 102, name: 'Mouse', price: 25 },
    { id: 103, name: 'Keyboard', price: 75 }
  ];
}
</code></pre>
                        <p class="h5">Selection with @switch</p>
                        <p>The <code>@switch</code> block allows for conditional rendering based on multiple possible
                            values of an
                            expression. It functions almost exactly like a JavaScript <code>switch</code> statement. It
                            matches the
                            value of the expression to the corresponding <code>@case</code> block. If no matches are
                            found, the
                            <code>@default</code> block is rendered.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-status-stepper',
  standalone: true,
  template: `
    &lt;div [class]="status"&gt;
      @switch (status) {
        @case ('pending') { &lt;span&gt;Order is awaiting confirmation.&lt;/span&gt; }
        @case ('shipped') { &lt;span&gt;Order is on the way!&lt;/span&gt; }
        @case ('delivered') { &lt;span&gt;Order arrived successfully.&lt;/span&gt; }
        @default { &lt;span&gt;Status unknown. Contact support.&lt;/span&gt; }
      }
    &lt;/div&gt;
  `
})
export class StatusStepperComponent {
  status: string = 'shipped';
}
</code></pre>
                        <p class="h5">Technical Comparison: New Syntax vs. Legacy Directives</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">New Block Syntax ( <code>@if</code>, <code>@for</code> )</th>
                                        <th scope="col">Legacy Directives ( <code>*ngIf</code>, <code>*ngFor</code> )
                                        </th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Performance</th>
                                        <td>Faster; built into the compiler.</td>
                                        <td>Slower; involves directive overhead.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Imports</th>
                                        <td>Automatically available in standalone.</td>
                                        <td>Requires importing <code>CommonModule</code>.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Syntax</th>
                                        <td>Concise; supports <code>@else</code>, <code>@empty</code>.</td>
                                        <td>Verbose; requires <code>&lt;ng-template&gt;</code> for else.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Type Safety</th>
                                        <td>Enhanced type narrowing within blocks.</td>
                                        <td>Limited type inference in complex cases.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p> The <code>track</code> property in <code>@for</code> is no longer optional. While
                                    you can use the item itself
                                    (<code>track $index</code> or <code>track item</code>), it is a best practice to use
                                    a unique ID from your
                                    data to ensure Angular can efficiently re-use DOM nodes during updates.</p>
                            </div>
                        </div>
                        <p class="h5">Migration and Edge Cases</p>
                        <p>If you are working on an older Angular project and wish to upgrade to the new control flow,
                            the Angular CLI provides an automated migration tool.
                        </p>
                        <pre><code class="language-bash"># Run this command to migrate your project to the new control flow syntax
ng generate @angular/core:control-flow
</code></pre>
                        <p class="h5">Edge Case: Null/Undefined Collections</p>
                        <p>In the legacy <code>*ngFor</code>, passing a null value would simply render nothing. In the
                            new <code>@for</code>, if
                            the collection is null or undefined, the <code>@empty</code> block will be triggered. This
                            behavior
                            ensures that your UI always has a defined state even when data is missing.
                        </p>
                        <p>Warning: Do not attempt to use the legacy <code>*ngIf</code> and the new <code>@if</code> on
                            the same HTML element.
                            While the compiler may allow the application to run, it creates confusing logic paths and
                            can lead to unexpected UI "flickering" during change detection cycles.
                        </p>
                    </section>

                    <section class="docs-section" id="item-2-5">
                        <p class="h3">Event Binding & Output</p>
                        <p>Communication in Angular follows a unidirectional data flow: data flows down from parents to
                            children via Property Binding, and notifications flow up from children to parents via Event
                            Binding. Event binding allows an application to respond to user input, such as keystrokes,
                            mouse clicks, or touch gestures. When a component needs to communicate a state change or an
                            action to its parent, it utilizes the <code>@Output</code> decorator combined with the
                            <code>EventEmitter</code>
                            class.
                        </p>
                        <p>This mechanism ensures that components remain encapsulated and decoupled. A child component
                            does not need to know which parent is listening to its events; it simply "emits" a signal,
                            and any interested parent can "bind" to that signal to execute logic.</p>
                        <p class="h5">Standard Event Binding</p>
                        <p>Standard event binding captures events from the DOM. The syntax consists of a target event
                            name within parentheses <code>()</code> on the left, and a template statement within quotes
                            on the right.
                            When the event occurs, Angular executes the statement.</p>
                        <p>To access the data associated with a DOM event (such as the value of an input field), Angular
                            provides a special <code>$event</code> object. This object contains the payload of the
                            event, such as the
                            <code>KeyboardEvent</code>or <code>MouseEvent</code> properties.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-click-logger',
  standalone: true,
  template: `
    &lt;div class="container"&gt;
      &lt;button (click)="onSave()"&gt;Save Data&lt;/button&gt;

      &lt;input (input)="onInputChange($event)" placeholder="Type something..." /&gt;
      
      &lt;p&gt;Current Input: {{ currentVal }}&lt;/p&gt;
    &lt;/div&gt;
  `
})
export class ClickLoggerComponent {
  currentVal = '';

  onSave() {
    console.log('Save button clicked!');
  }

  onInputChange(event: Event) {
    // Explicit casting is required for TypeScript type safety
    const inputElement = event.target as HTMLInputElement;
    this.currentVal = inputElement.value;
  }
}
</code></pre>
                        <p class="h5">Component Communication with @Output</p>
                        <p>When creating reusable components, you often need to emit custom events. To do this, you
                            define a property in the child component class, decorate it with <code>@Output()</code>, and
                            initialize
                            it as a new <code>EventEmitter</code>. The parent component then uses the same parenthesis
                            syntax to
                            listen for that custom event.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Member</th>
                                        <th scope="col">Type</th>
                                        <th scope="col">Role</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>@Output()</strong></td>
                                        <td>Decorator</td>
                                        <td>Marks a class property as an event gateway for parent components.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>EventEmitter</strong></td>
                                        <td>Class</td>
                                        <td>A specialized class used to emit custom values synchronously or
                                            asynchronously.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>.emit()</strong></td>
                                        <td>Method</td>
                                        <td>The function called to broadcast the event payload to listeners.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Example: Child to Parent Communication</p>
                        <p>In this scenario, the <code>ItemDetailComponent</code> (child) notifies the
                            <code>StoreComponent</code> (parent) that a product has been added to the cart.
                        </p>
                        <p class="h5">Child Component:</p>
                        <pre><code class="language-javascript">import { Component, Output, EventEmitter, Input } from '@angular/core';

@Component({
  selector: 'app-item-detail',
  standalone: true,
  template: `
    &lt;div class="item"&gt;
      &lt;span&gt;{{ itemName }}&lt;/span&gt;
      &lt;button (click)="addToCart()"&gt;Add to Cart&lt;/button&gt;
    &lt;/div&gt;
  `
})
export class ItemDetailComponent {
  @Input() itemName = '';
  @Output() itemAdded = new EventEmitter&lt;string&gt;();

  addToCart() {
    // Emitting the name of the item back to the parent
    this.itemAdded.emit(this.itemName);
  }
}
</code></pre>
                        <p class="h5">Parent Component Template:</p>
                        <pre><code class="language-html">&lt;app-item-detail 
  [itemName]="'Wireless Mouse'" 
  (itemAdded)="handleItem($event)"&gt;
&lt;/app-item-detail&gt;
</code></pre>
                        <p class="h5">Event Options and Modifiers</p>
                        <p>Angular provides ways to optimize event handling, particularly when dealing with event
                            bubbling or default browser behaviors. While Angular doesn't have "modifiers" in the
                            template syntax like Vue (e.g., <code>.prevent</code>), you handle these logic requirements
                            within the
                            TypeScript method.</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Scenario</th>
                                        <th scope="col">Strategy</th>
                                        <th scope="col">Code Example</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Prevent Reload</th>
                                        <td>Call <code>preventDefault()</code> on the event.</td>
                                        <td><code>event.preventDefault();</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Stop Propagation</th>
                                        <td>Call <code>stopPropagation()</code> to stop bubbling.</td>
                                        <td><code>event.stopPropagation();</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Passive Events</th>
                                        <td>Handled via <code>zone.js</code> or global listeners.</td>
                                        <td>Optimized for scrolling performance.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>For modern Angular (v16+), you can also use Signals for state management, but
                                    <code>@Output</code> remains the standard for emitting discrete actions or
                                    notifications from a component to its parent.
                                </p>
                            </div>
                        </div>
                        <p class="h5">Best Practices for Outputs</p>
                        <ol>
                            <li>Naming Conventions: Do not prefix your output names with "on" (e.g., use
                                <code>changed</code> rather
                                than <code>onChanged</code>). The event binding syntax <code>(changed)</code> already
                                implies "on."
                            </li>
                            <li>Explicit Typing: Always provide a generic type to your <code>EventEmitter</code>, such
                                as <code>new</code>
                                <code>EventEmitter&lt;number&gt;()</code>, to ensure type safety in the parent's
                                handler.
                            </li>
                            <li>Cleanup: <code>EventEmitter</code> is an implementation of an Observable, but Angular
                                handles the
                                unsubscription automatically for these template bindings, so manual cleanup in
                                <code>ngOnDestroy</code> is usually unnecessary for <code>@Output</code>.
                            </li>
                        </ol>
                        <p>Warning: Avoid emitting events in the <code>ngOnChanges</code> or <code>ngOnInit</code>
                            lifecycle hooks of the same
                            component. Emitting an event during the initialization phase can lead to
                            "ExpressionChangedAfterItHasBeenCheckedError" because it might trigger a state change in the
                            parent while the parent is still in the middle of its own rendering cycle.
                        </p>
                    </section>

                    <section class="docs-section" id="item-2-6">
                        <p class="h3">Two-Way Binding ([(ngModel)])</p>
                        <p>Two-way data binding provides a synchronization mechanism that allows data to flow in both
                            directions: from the component class to the template, and from the template back to the
                            component class. This is most commonly used in data-entry forms where you want the UI (an
                            input field) to reflect a value from your model, and you simultaneously want the model to
                            update immediately when the user changes the input.
                        </p>
                        <p>In Angular, this is achieved using the "Banana-in-a-Box" syntax: <code>[(ngModel)]</code>.
                            This syntax is
                            a shorthand combination of Property Binding <code>[]</code> (data to the view) and Event
                            Binding <code>()</code> (data
                            from the view).
                        </p>
                        <p class="h5">Enabling Two-Way Binding</p>
                        <p>The <code>ngModel</code> directive is not part of the Angular core package. It belongs to the
                            <code>FormsModule</code>.
                            In a standalone component, you must explicitly import <code>FormsModule</code> into the
                            <code>imports</code> array of
                            the <code>@Component</code> decorator to use this syntax.
                        </p>
                        <p>Once imported, <code>ngModel</code> handles the heavy lifting: it listens for input events,
                            updates the
                            class property, and pushes the property value back into the input element's property.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms'; // Required for ngModel

@Component({
  selector: 'app-user-settings',
  standalone: true,
  imports: [FormsModule],
  template: `
    &lt;div class="settings-form"&gt;
      &lt;h3&gt;Edit Profile&lt;/h3&gt;
      
      &lt;label&gt;Username:&lt;/label&gt;
      &lt;input [(ngModel)]="username" placeholder="Enter username" /&gt;

      &lt;label&gt;Bio:&lt;/label&gt;
      &lt;textarea [(ngModel)]="bio"&gt;&lt;/textarea&gt;

      &lt;div class="preview"&gt;
        &lt;h4&gt;Preview:&lt;/h4&gt;
        &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt; {{ username }}&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; {{ bio }}&lt;/p&gt;
      &lt;/div&gt;
      
      &lt;button (click)="resetForm()"&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  `,
  styles: [`
    .settings-form { display: flex; flex-direction: column; gap: 10px; max-width: 300px; }
    .preview { margin-top: 20px; padding: 10px; border: 1px dashed #ccc; }
  `]
})
export class UserSettingsComponent {
  username: string = 'Developer_One';
  bio: string = 'Building the future with Angular.';

  resetForm() {
    this.username = '';
    this.bio = '';
  }
}
</code></pre>
                        <p class="h5">Deconstructing the Syntax</p>
                        <p>The <code>[(ngModel)]</code> syntax is actually a syntactic sugar for a longer form.
                            Understanding this deconstruction is helpful when you need to perform additional logic (like
                            validation or formatting) during the update process rather than just a direct assignment.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Syntax</th>
                                        <th scope="col">Type</th>
                                        <th scope="col">Action</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>[ngModel]</code></td>
                                        <td>Property Binding</td>
                                        <td>Sets the value of the input element to the property value.</td>
                                    </tr>
                                    <tr>
                                        <td><code>(ngModelChange)</code></td>
                                        <td>Event Binding</td>
                                        <td>Listens for changes and updates the property in the class.</td>
                                    </tr>
                                    <tr>
                                        <td><code>[(ngModel)]</code></td>
                                        <td>Two-way Binding</td>
                                        <td>Combines both for automatic synchronization.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">The Expanded Version:</p>
                        <pre><code class="language-html">&lt;input [ngModel]="username" (ngModelChange)="username = $event"&gt;
</code></pre>
                        <p class="h5">Usage with Different Form Elements</p>
                        <p>The <code>ngModel</code> directive is versatile and adapts its behavior based on the type of
                            HTML element it is applied to.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Element</th>
                                        <th scope="col">Event Listened To</th>
                                        <th scope="col">Property Updated</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>&lt;input type="text"&gt;</code></td>
                                        <td><code>input</code></td>
                                        <td><code>value</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>&lt;input type="checkbox"&gt;</code></td>
                                        <td><code>change</code></td>
                                        <td><code>checked</code> (boolean)</td>
                                    </tr>
                                    <tr>
                                        <td><code>&lt;select&gt;</code></td>
                                        <td><code>change</code></td>
                                        <td><code>value</code> of the selected option</td>
                                    </tr>
                                    <tr>
                                        <td><code>&lt;input type="radio"&gt;</code></td>
                                        <td><code>change</code></td>
                                        <td><code>value</code> of the selected radio</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>When using <code>[(ngModel)]</code> inside an HTML
                                    <code>&lt;form&gt;</code> tag, you must define a <code>name</code> attribute on the
                                    input element. Angular uses this
                                    name to register the control with the internal <code>NgForm</code> instance that is
                                    automatically
                                    created for the form.
                                </p>
                            </div>
                        </div>
                        <p class="h5">Comparison: Two-Way Binding vs. Signals</p>
                        <p>With the introduction of Angular Signals (v16+), developers have a more performant way to
                            handle reactive state. While <code>[(ngModel)]</code> is still widely used for simple forms,
                            Signals provide a more granular way to track changes across the entire application without
                            the overhead of heavy change detection cycles.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Aspect</th>
                                        <th scope="col">ngModel (Two-Way)</th>
                                        <th scope="col">Signals (Model Input)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Complexity</th>
                                        <td>Simple, "magic" synchronization.</td>
                                        <td>Requires signal functions <code>()</code> to read.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Performance</th>
                                        <td>Triggers full change detection.</td>
                                        <td>Updates only the specific parts of the DOM.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Imports</th>
                                        <td>Requires <code>FormsModule</code>.</td>
                                        <td>Part of <code>@angular/core</code>.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Use Case</th>
                                        <td>Quick forms and internal component state.</td>
                                        <td>Scalable state management and high-performance UIs.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Edge Case: Custom Form Controls</p>
                        <p>By default, <code>ngModel</code> only works on standard HTML form elements. If you create a
                            custom
                            component (like a custom star-rating component) and want to use <code>[(ngModel)]</code> on
                            it, your
                            component must implement the <code>ControlValueAccessor</code> interface. This tells Angular
                            how to
                            "write" a value to your component and how to "read" when a value inside your component
                            changes.
                        </p>
                        <p>Warning: Overusing two-way data binding in very large forms can lead to performance
                            degradation because every keystroke triggers a change detection cycle for the entire
                            component tree. For complex, high-performance forms, Reactive Forms are generally
                            recommended over template-driven <code>ngModel</code>.
                        </p>
                    </section>

                    <section class="docs-section" id="item-2-7">
                        <p class="h3">Content Projection (&lt;ng-content&gt;)</p>
                        <p>Content projection is a pattern in which you insert, or "project," the content you want to
                            use inside another component. Typically, when you place HTML or other components between the
                            opening and closing tags of a custom component (e.g.,
                            <code>&lt;app-card&gt;...&lt;/app-card&gt;</code>), Angular
                            ignores that content by default. Content projection allows you to create "wrapper"
                            components—such as modals, cards, or layouts—that provide a consistent frame around dynamic
                            content provided by the parent.
                        </p>
                        <p>This is achieved using the <code>&lt;ng-content&gt;</code>element. It acts as a placeholder
                            that tells Angular
                            where to render the content it finds between the host component's tags. This mechanism
                            is vital for building highly reusable UI libraries where the container's structure is
                            fixed, but the internal content varies.
                        </p>
                        <p class="h5">Basic Single-Slot Projection</p>
                        <p>In its simplest form, you place a single <code>&lt;ng-content&gt;&lt;/ng-content&gt;</code>
                            tag inside your
                            component's template. When the parent component uses the child, any elements placed inside
                            the child's tags will be "projected" into that exact spot.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-simple-card',
  standalone: true,
  template: `
    &lt;div class="card-frame"&gt;
      &lt;div class="card-body"&gt;
        &lt;ng-content&gt;&lt;/ng-content&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `,
  styles: [`
    .card-frame { border: 1px solid #ddd; padding: 1rem; border-radius: 8px; }
  `]
})
export class SimpleCardComponent {}
</code></pre>
                        <p class="h5">Usage in Parent:</p>
                        <pre><code class="language-html">&lt;app-simple-card&gt;
  &lt;p&gt;This paragraph is projected into the card body.&lt;/p&gt;
&lt;/app-simple-card&gt;
</code></pre>
                        <p class="h5">Multi-Slot (Named) Projection</p>
                        <p>Often, a component needs multiple placeholders—for example, a card with a header, a body, and
                            a footer. Angular supports this via the <code>select</code> attribute on the
                            <code>&lt;ng-content&gt;</code> tag. The select
                            attribute uses CSS selectors to determine which content goes into which slot. You can
                            <code>select</code> content based on tag names, classes, or attributes.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Selector Type</th>
                                        <th scope="col">Example Syntax</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Tag Selector</th>
                                        <td><code>select="header"</code></td>
                                        <td>Projects elements with the <code>&lt;header&gt;</code> tag.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Class Selector</th>
                                        <td><code>select=".card-bio"</code></td>
                                        <td>Projects elements having the <code>card-bio</code> CSS class.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Attribute Selector</th>
                                        <td><code>select="[card-info]"</code></td>
                                        <td>Projects elements with the <code>card-info</code> attribute.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Default</th>
                                        <td>No <code>select</code> attribute</td>
                                        <td>Projects all content that didn't match other slots.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">@Component({
  selector: 'app-fancy-card',
  standalone: true,
  template: `
    &lt;div class="card"&gt;
      &lt;header class="card-header"&gt;
        &lt;ng-content select="[header]"&gt;&lt;/ng-content&gt;
      &lt;/header&gt;
      
      &lt;main class="card-content"&gt;
        &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/main&gt;
      
      &lt;footer class="card-footer"&gt;
        &lt;ng-content select=".footer-actions"&gt;&lt;/ng-content&gt;
      &lt;/footer&gt;
    &lt;/div&gt;
  `
})
export class FancyCardComponent {}
</code></pre>
                        <p class="h5">Usage in Parent:</p>
                        <pre><code class="language-html">&lt;app-fancy-card&gt;
  &lt;h2 header&gt;Project Title&lt;/h2&gt;
  
  &lt;p&gt;This is the main description of the project.&lt;/p&gt;
  
  &lt;div class="footer-actions"&gt;
    &lt;button&gt;Like&lt;/button&gt;
    &lt;button&gt;Share&lt;/button&gt;
  &lt;/div&gt;
&lt;/app-fancy-card&gt;
</code></pre>
                        <p class="h5">Content vs. View: Lifecycle Implications</p>
                        <p>Projected content is considered "Content" rather than "View" for the component receiving it.
                            This distinction is important for lifecycle hooks. If you need to interact with projected
                            elements from your TypeScript code, you cannot use <code>@ViewChild</code>. Instead, you
                            must use
                            <code>@ContentChild</code> or <code>@ContentChildren</code>.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Lifecycle Hook</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><code>ngAfterContentInit</code></th>
                                        <td>Called after Angular performs the initial projection.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>ngAfterContentChecked</code></th>
                                        <td>Called after every check of the projected content.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">import { Component, ContentChild, ElementRef, AfterContentInit } from '@angular/core';

@Component({ selector: 'app-content-checker', standalone: true, template: `&lt;ng-content&gt;&lt;/ng-content&gt;` })
export class ContentCheckerComponent implements AfterContentInit {
  // Looking for an element with the #info template variable in projected content
  @ContentChild('info') projectedInfo!: ElementRef;

  ngAfterContentInit() {
    console.log('Projected content is ready:', this.projectedInfo.nativeElement.textContent);
  }
}
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>The <code>&lt;ng-content&gt;</code> tag does not create a real DOM element. It is a
                                    "shadow" element
                                    used by the Angular compiler. Consequently, you cannot apply CSS classes or
                                    directives directly to <code>&lt;ng-content&gt;</code>. If you need to style the
                                    wrapper, apply
                                    those styles to the surrounding <code>div</code> or container.</p>
                            </div>
                        </div>
                        <p class="h5">Comparison: ng-content vs. ng-template</p>
                        <p>While both are used for dynamic UI, they serve different architectural goals.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">ng-content</th>
                                        <th scope="col">ng-template</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Evaluation</th>
                                        <td>Content is evaluated by the parent.</td>
                                        <td>Content is evaluated only when instantiated.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Reusability</th>
                                        <td>Projected once into a specific slot.</td>
                                        <td>Can be stamped out multiple times (e.g., in a loop).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Control</th>
                                        <td>Child has limited control over content logic.</td>
                                        <td>Child decides when and how to render the template.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Usage</th>
                                        <td>Creating layout wrappers.</td>
                                        <td>Creating highly dynamic UI like tooltips or virtual scrolls.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p>Warning: Content projected via <code>&lt;ng-content&gt;</code> is always initialized and
                            exists in memory, even if it is
                            hidden by an <code>@if</code> block inside the child component. This is because the parent
                            component
                            owns the lifecycle of that content. For performance-heavy content that should only exist
                            when needed, consider using Template Projection with <code>ng-template</code>.</p>
                    </section>

                    <section class="docs-section" id="item-2-8">
                        <p class="h3">View Encapsulation (CSS Scoping)</p>
                        <p>In traditional web development, CSS is globally scoped. A style defined for a <code>p</code>
                            tag in one
                            stylesheet can inadvertently affect every paragraph across the entire website. Angular
                            solves this problem through View Encapsulation. This mechanism ensures that the styles
                            defined within a component's metadata are isolated to that component's template, preventing
                            "CSS leakage" where styles bleed out to the rest of the application or bleed in from other
                            components.
                        </p>
                        <p>Angular achieves this by default by modifying the CSS selectors and the HTML elements during
                            the build process. It appends unique attributes (such as <code>_ngcontent-c1</code>) to the
                            component's
                            elements and updates the CSS rules to target those specific attributes. This creates a
                            sandbox environment for every component's UI.
                        </p>
                        <p class="h5">Encapsulation Modes</p>
                        <p>Angular provides three distinct strategies for handling view encapsulation. You can configure
                            these per component using the <code>encapsulation</code> property in the
                            <code>@Component</code> decorator.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Mode</th>
                                        <th scope="col">Description</th>
                                        <th scope="col">Behavior</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Emulated (Default)</th>
                                        <td>Styles are scoped to the component using unique attributes.</td>
                                        <td>Simulates Shadow DOM behavior without requiring browser support.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">None</th>
                                        <td>Styles are added to the global <code>&lt;head&gt;</code> of the document.
                                        </td>
                                        <td>Scoping is disabled; styles affect the entire application.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">ShadowDom</th>
                                        <td>Uses the browser's native Shadow DOM API.</td>
                                        <td>Provides true isolation; styles cannot cross the shadow boundary.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Implementing Encapsulation Modes</p>
                        <p>To change the default behavior, you must import <code>ViewEncapsulation</code> from
                            <code>@angular/core</code>.
                        </p>
                        <pre><code class="language-javascript">import { Component, ViewEncapsulation } from '@angular/core';

@Component({
  selector: 'app-encapsulation-demo',
  standalone: true,
  template: `
    &lt;div class="banner"&gt;
      &lt;h1&gt;Encapsulated Header&lt;/h1&gt;
    &lt;/div&gt;
  `,
  styles: [`
    /* This style only affects .banner inside THIS component */
    .banner { background-color: #007bff; color: white; padding: 10px; }
  `],
  encapsulation: ViewEncapsulation.Emulated // Default, can be omitted
})
export class EncapsulationComponent {}
</code></pre>
                        <p class="h5">Deep Dive: Penetrating the Boundary with ::ng-deep</p>
                        <p>Sometimes, a parent component needs to force a style onto a child component or a third-party
                            library component where you do not have access to the source code. For these scenarios,
                            Angular provides the <code>::ng-deep</code> pseudo-class. When you prefix a selector with
                            <code>::ng-deep</code>,
                            Angular disables encapsulation for that specific rule, allowing the style to act globally or
                            "pierce" down into child components.
                        </p>
                        <pre><code class="language-javascript">@Component({
  selector: 'app-parent-styler',
  standalone: true,
  template: `&lt;app-third-party-widget&gt;&lt;/app-third-party-widget&gt;`,
  styles: [`
    /* Targets a class inside the child component, even though it's encapsulated */
    :host ::ng-deep .widget-title {
      color: gold;
      font-weight: bold;
    }
  `]
})
export class ParentStylerComponent {}                        
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>The <code>:host</code> selector is a special pseudo-class used to target the
                                    component's host
                                    element itself (the custom tag, e.g., <code>&lt;app-encapsulation-demo&gt;</code>).
                                    It is the
                                    only way
                                    to style the outer shell of your component from within its own CSS file.</p>
                            </div>
                        </div>
                        <p class="h5">Comparison: Shadow DOM vs. Emulated</p>
                        <p>While both aim for isolation, they function differently at the browser level.</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped border">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Emulated (Default)</th>
                                        <th scope="col">ShadowDom (Native)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Browser Support</th>
                                        <td>All modern browsers.</td>
                                        <td>Only browsers supporting Web Components.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">DOM Structure</th>
                                        <td>Regular DOM with attributes.</td>
                                        <td>Separate <code>#shadow-root</code> in the inspector.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Global Styles</th>
                                        <td>Global styles (like <code>body</code> fonts) still apply.</td>
                                        <td>Global styles are strictly blocked from entering.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Performance</th>
                                        <td>High; minimal overhead.</td>
                                        <td>Slightly more overhead due to browser API.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Advanced Selectors</p>
                        <p>Angular CSS scoping includes specific pseudo-classes to manage complex styling hierarchies.
                        </p>
                        <ul>
                            <li>:host-context(): Used to style a component based on a condition in its ancestors. For
                                example, applying a "dark theme" class if any parent has a <code>.dark-mode</code>
                                class.
                            </li>
                            <li>:host: Used to style the host element.
                            </li>
                        </ul>
                        <pre><code class="language-css">/* Style the host only if it has the .active class */
:host(.active) {
  border: 2px solid green;
}

/* Style the component differently if it's inside a 'dark-theme' container */
:host-context(.dark-theme) h1 {
  color: #efefef;
}
</code></pre>
                        <p>Warning: Use <code>::ng-deep</code> with extreme caution. Because it makes the style global,
                            it can lead
                            to maintenance difficulties where styles unintentionally override other parts of your
                            application. Always wrap <code>::ng-deep</code> inside a <code>:host</code> selector to
                            limit its scope to the current
                            component's children only.
                        </p>
                    </section>
                </article>

                <article class="docs-article" id="section-3">
                    <header class="docs-header">
                        <p class="h2 docs-heading">Section 3: Signals & Reactivity (Modern Core)</p>
                    </header>
                    <hr>
                    <section class="docs-section" id="item-3-1">
                        <p class="h3">Angular Signals (Writable & Computed)</p>
                        <p>Introduced as the most significant change to Angular's reactivity model in years, Signals
                            provide a granular way to manage state. Unlike the traditional change detection mechanism
                            that checks the entire component tree when an event occurs, Signals allow Angular to
                            identify the specific parts of the UI that need to be updated. This "fine-grained
                            reactivity" results in significantly better performance and a more predictable data flow.
                        </p>
                        <p>A Signal is a wrapper around a value that notifies interested consumers when that value
                            changes. When a signal is read within a template or another reactive context, Angular
                            automatically tracks that dependency. If the signal's value is updated later, Angular knows
                            exactly which components or computations need to be re-evaluated.
                        </p>
                        <p class="h5">Writable Signals</p>
                        <p>A Writable Signal allows you to directly update its value. You create one using the
                            <code>signal()</code>
                            function. To read the value of a signal, you call it as a function (e.g.,
                            <code>count()</code>). This
                            function call is what allows Angular to register the dependency.
                        </p>
                        <p>To modify the value, you use the <code>.set()</code> method for a brand new value, or the
                            <code>.update()</code> method
                            when the new value depends on the previous one.
                        </p>
                        <pre><code class="language-javascript">import { Component, signal } from '@angular/core';

@Component({
  selector: 'app-counter',
  standalone: true,
  template: `
    &lt;div class="counter-box"&gt;
      &lt;h2&gt;Counter: {{ count() }}&lt;/h2&gt;
      &lt;button (click)="increment()"&gt;+1&lt;/button&gt;
      &lt;button (click)="reset()"&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  `
})
export class CounterComponent {
  // Initializing a Writable Signal
  count = signal(0);

  increment() {
    // Update based on the previous value
    this.count.update(value =&gt; value + 1);
  }

  reset() {
    // Set to a specific value
    this.count.set(0);
  }
}
</code></pre>
                        <p class="h5">Computed Signals</p>
                        <p>A Computed Signal is a reactive value that derives its state from other signals. It is
                            defined using the <code>computed()</code> function. Computed signals are read-only; you
                            cannot manually set their value. Instead, they automatically re-calculate whenever any of
                            the signals they depend on change.
                        </p>
                        <p>One of the most powerful features of computed signals is that they are lazily evaluated and
                            memoized. The calculation only runs the first time you read the signal, and then the result
                            is cached. It will only re-calculate if its dependency signals change.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Writable Signal</th>
                                        <th scope="col">Computed Signal</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Creation</th>
                                        <td><code>signal(initialValue)</code></td>
                                        <td><code>computed(() => derivation)</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Mutability</th>
                                        <td>Mutable via <code>.set()</code> and <code>.update()</code>.</td>
                                        <td>Read-only (Immutable).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Dependency</th>
                                        <td>None.</td>
                                        <td>Automatically tracks signals called inside.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Use Case</th>
                                        <td>Storing primary state (e.g., user input).</td>
                                        <td>Deriving data (e.g., filtered lists, totals).</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">import { Component, signal, computed } from '@angular/core';

@Component({
  selector: 'app-shopping-cart',
  standalone: true,
  template: `
    &lt;p&gt;Price: {{ price() | currency }}&lt;/p&gt;
    &lt;p&gt;Quantity: {{ quantity() }}&lt;/p&gt;
    &lt;hr&gt;
    &lt;p&gt;&lt;strong&gt;Total: {{ total() | currency }}&lt;/strong&gt;&lt;/p&gt;
    &lt;button (click)="add()"&gt;Add One&lt;/button&gt;
  `
})
export class ShoppingCartComponent {
  price = signal(100);
  quantity = signal(1);

  // Deriving a value reactively
  total = computed(() =&gt; this.price() * this.quantity());

  add() {
    this.quantity.update(q =&gt; q + 1);
  }
}
</code></pre>
                        <p class="h5">Signal Equality and Optimization</p>
                        <p>By default, signals use referential equality (<code>===</code>) to determine if a value has
                            changed. If you set a signal to the same value it already holds, consumers are not notified,
                            and no UI updates occur. When working with objects or arrays, you can provide a custom
                            equality function to the signal configuration to control this behavior.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Configuration Option</th>
                                        <th scope="col">Type</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">equal</th>
                                        <td>Function</td>
                                        <td>A custom comparator to decide if the new value is different from the old.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Because signals are functions, you must always include the parentheses () when
                                    accessing them in your TypeScript code or HTML templates. Forgetting the parentheses
                                    will pass the signal object itself rather than its value, often resulting in
                                    <code>[function]</code> appearing in your UI.
                                </p>
                            </div>
                        </div>
                        <p class="h5">Comparison: Signals vs. RxJS Observables</p>
                        <p>While both handle reactivity, Signals and RxJS (Observables) are intended for different use
                            cases. Signals are designed for state management within the UI, while RxJS is designed for
                            asynchronous event streams (like HTTP requests or web sockets).
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Aspect</th>
                                        <th scope="col">Signals</th>
                                        <th scope="col">RxJS Observables</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Value Availability</th>
                                        <td>Always synchronous.</td>
                                        <td>Can be synchronous or asynchronous.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Subscription</th>
                                        <td>Automatic (via tracking).</td>
                                        <td>Manual (via <code>.subscribe()</code> or <code>async</code> pipe).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Glitches</th>
                                        <td>No "glitch" (intermediate states).</td>
                                        <td>Can suffer from transient inconsistent states.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Complexity</th>
                                        <td>Simple; tailored for UI state.</td>
                                        <td>High; powerful operators for complex logic.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p>Warning: Do not perform "side effects" (like making an HTTP call or manually modifying the
                            DOM) inside a <code>computed()</code> function. Computed signals should be "pure"—they
                            should only
                            calculate and return a value based on their dependencies.
                        </p>
                    </section>

                    <section class="docs-section" id="item-3-2">
                        <p class="h3">Effects</p>
                        <p>While Signals and Computed Signals are designed to manage and derive state, Effects are
                            designed to handle side effects. An effect is an operation that runs whenever one or more
                            signal values change. Unlike a computed signal, which must be "pure" and return a value, an
                            effect is a "fire-and-forget" mechanism used for tasks that stay outside the typical data
                            flow, such as logging, manual DOM manipulation, or synchronizing data with local storage.
                        </p>
                        <p>An effect is created using the <code>effect()</code> function. Much like a computed signal,
                            an effect
                            automatically tracks every signal called within its function body. When any of those signals
                            change, the effect is scheduled to run again.
                        </p>
                        <p class="h5">Creating and Using Effects</p>
                        <p>Effects must be created within an injection context, such as a component’s constructor or a
                            field initializer. This is because effects are tied to the lifecycle of the object that
                            creates them; when the component is destroyed, the effect is automatically cleaned up.
                        </p>
                        <pre><code class="language-javascript">import { Component, signal, effect } from '@angular/core';

@Component({
  selector: 'app-logger-demo',
  standalone: true,
  template: `
    &lt;button (click)="increment()"&gt;Increment: {{ count() }}&lt;/button&gt;
  `
})
export class LoggerComponent {
  count = signal(0);

  constructor() {
    // Defining an effect in the constructor (Injection Context)
    effect(() =&gt; {
      console.log(`The current count is: ${this.count()}`);
      
      // You could also sync with LocalStorage here
      localStorage.setItem('app_count', this.count().toString());
    });
  }

  increment() {
    this.count.update(c =&gt; c + 1);
  }
}
</code></pre>
                        <p class="h5">Effect Execution Timing</p>
                        <p>Effects do not run immediately when a signal changes. Instead, they are scheduled and run
                            during the microtask phase. This means that if you update a signal three times in a single
                            synchronous block of code, the effect will only run once with the final value. This batching
                            mechanism prevents unnecessary work and ensures the UI remains performant.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Aspect</th>
                                        <th scope="col">Behavior</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Scheduling</th>
                                        <td>Runs asynchronously after the code that updated the signal.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Batching</th>
                                        <td>Multiple signal updates trigger only one effect execution.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Cleanup</th>
                                        <td>Automatically destroyed with the component/service.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Tracking</th>
                                        <td>Dynamic; it tracks only the signals read during the last execution.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Manual Cleanup with onCleanup</p>
                        <p>Sometimes an effect starts a process that needs to be stopped before the next run—such as a
                            <code>setTimeout</code> or a manual subscription. The <code>effect()</code> function
                            provides an <code>onCleanup</code> callback as
                            an argument to handle these scenarios.
                        </p>
                        <pre><code class="language-javascript">effect((onCleanup) =&gt; {
  const user = this.currentUser();
  
  const timer = setTimeout(() =&gt; {
    console.log(`User ${user} has been active for 5 seconds`);
  }, 5000);

  // This runs before the effect re-runs OR when the component is destroyed
  onCleanup(() =&gt; {
    clearTimeout(timer);
  });
});
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Effects are rarely needed for most application logic. Before using an effect, ask if
                                    the task could be handled by a <code>computed</code> signal or a standard event
                                    handler. Effects
                                    are best reserved for "leaf-node" operations like logging or integrating with
                                    non-Angular libraries.
                                </p>
                            </div>
                        </div>
                        <p class="h5">Advanced Configuration: Manual Cleanup</p>
                        <p>While effects are automatically destroyed, you can choose to manage the lifecycle manually by
                            capturing the <code>EffectRef</code> returned by the <code>effect()</code> function. This is
                            useful if you want to stop
                            the effect based on a specific user action rather than waiting for component destruction.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Option</th>
                                        <th scope="col">Type</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><code>manualCleanup</code></th>
                                        <td>boolean</td>
                                        <td>If true, the effect won't destroy itself with the component.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>allowSignalWrites</code></th>
                                        <td>boolean</td>
                                        <td><strong>(Discouraged)</strong> Allows updating other signals inside the
                                            effect.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">export class ManualEffectComponent {
  data = signal(null);
  
  // Storing the reference to the effect
  private loggingEffect = effect(() =&gt; {
    console.log('Data changed:', this.data());
  });

  stopLogging() {
    // Manually destroying the effect
    this.loggingEffect.destroy();
  }
}
</code></pre>
                        <p>Warning: By default, Angular prevents you from writing to a signal inside an
                            <code>effect()</code> (e.g.,
                            <code>this.otherSignal.set(val)</code>). This is to prevent "infinite circular updates"
                            where an effect
                            updates a signal that then triggers the same effect again. While you can bypass this with
                            <code>allowSignalWrites: true</code>, it is a significant anti-pattern and usually indicates
                            a flaw in
                            the application's reactive architecture.
                        </p>
                    </section>

                    <section class="docs-section" id="item-3-3">
                        <p class="h3">RxJS Interop with Signals</p>
                        <p>As Angular evolves toward a signal-based reactive core, developers frequently need to bridge
                            the gap between Signals and RxJS Observables. While Signals excel at managing synchronous
                            state and UI updates, RxJS remains the industry standard for handling asynchronous events,
                            data streams, and complex transformations like debouncing or polling.
                        </p>
                        <p>To facilitate this, Angular provides the <code>@angular/core/rxjs-interop</code> package.
                            This library
                            offers utility functions to convert Observables into Signals and vice versa, allowing you to
                            leverage the strengths of both systems within a single application.</p>
                        <p class="h5">Converting Observables to Signals: <code>toSignal()</code></p>
                        <p>The <code>toSignal()</code> function tracks an Observable and returns a Signal that always
                            reflects the
                            latest value emitted by that Observable. This is particularly useful for handling HTTP
                            requests or state streams in a component without the need for manual subscriptions or the
                            <code>async</code> pipe.
                        </p>
                        <p>When you use <code>toSignal()</code>, the subscription is automatically managed. Angular
                            subscribes when
                            the signal is created and unsubscribes when the surrounding context (like a component or
                            service) is destroyed.
                        </p>
                        <pre><code class="language-javascript">import { Component, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { toSignal } from '@angular/core/rxjs-interop';

@Component({
  selector: 'app-user-list',
  standalone: true,
  template: `
    @for (user of users(); track user.id) {
      &lt;div&gt;{{ user.name }}&lt;/div&gt;
    } @empty {
      &lt;p&gt;No users found or loading...&lt;/p&gt;
    }
  `
})
export class UserListComponent {
  private http = inject(HttpClient);

  // Convert an Observable stream directly into a Signal
  users = toSignal(
    this.http.get&lt;any[]&gt;('https://api.example.com/users'), 
    { initialValue: [] }
  );
}
</code></pre>
                        <p class="h5"><code>toSignal</code> Configuration Options</p>
                        <p>Because Signals must always have a value, but Observables might not emit immediately,
                            <code>toSignal</code> provides several ways to handle the initial state and potential
                            errors.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Option</th>
                                        <th scope="col">Type</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><code>initialValue</code></th>
                                        <td><span>T</span></td>
                                        <td>The value the signal holds before the Observable emits its first item.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>requireSync</code></th>
                                        <td><span>boolean</span></td>
                                        <td>If true, the Observable must emit synchronously upon subscription.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>manualCleanup</code></th>
                                        <td><span>boolean</span></td>
                                        <td>If true, you must manually destroy the underlying subscription.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>rejectErrors</code></th>
                                        <td><span>boolean</span></td>
                                        <td>If true, any error in the Observable will cause the signal to throw an error
                                            on read.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>If an Observable emits an error, the signal created by <code>toSignal</code> will
                                    throw that error
                                    whenever the signal is read. It is highly recommended to use RxJS error-handling
                                    operators like <code>catchError</code> within the Observable stream before passing
                                    it to
                                    <code>toSignal</code>.
                                </p>
                            </div>
                        </div>
                        <p class="h5">Converting Signals to Observables: <code>toObservable()</code></p>
                        <p>The <code>toObservable()</code> function creates an Observable that emits the current value
                            of a signal
                            whenever that signal changes. This is essential when you want to use RxJS operators (like
                            <code>debounceTime</code>, <code>switchMap</code>, or <code>filter</code>) on a value that
                            is stored in a Signal.
                        </p>
                        <p>This conversion occurs inside an effect. Consequently, the Observable emits values
                            asynchronously (during the microtask phase) rather than immediately when the signal's value
                            is set.
                        </p>
                        <pre><code class="language-javascript">import { Component, signal } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';
import { debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';

@Component({
  selector: 'app-search',
  standalone: true,
  template: `&lt;input (input)="updateQuery($event)" placeholder="Search..."&gt;`
})
export class SearchComponent {
  searchQuery = signal('');

  // Convert the signal to an observable to use RxJS power
  searchData$ = toObservable(this.searchQuery).pipe(
    debounceTime(300),
    distinctUntilChanged(),
    switchMap(query =&gt; this.performSearch(query))
  );

  updateQuery(event: Event) {
    const val = (event.target as HTMLInputElement).value;
    this.searchQuery.set(val);
  }

  private performSearch(query: string) {
    // Return search logic...
  }
}
                        </code></pre>
                        <p class="h5">Choosing the Right Tool</p>
                        <p>Knowing when to use a Signal versus an Observable is key to writing clean, maintainable
                            Angular code.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Use Case</th>
                                        <th scope="col">Recommended Tool</th>
                                        <th scope="col">Why?</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Component State</th>
                                        <td>Signal</td>
                                        <td>Simple API, synchronous access, and efficient UI updates.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Derived UI Data</th>
                                        <td>Computed Signal</td>
                                        <td>Automatic dependency tracking and lazy evaluation.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">HTTP Requests</th>
                                        <td>RxJS Observable</td>
                                        <td>Handles completion, errors, and cancellation (aborting) naturally.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">User Input Streams</th>
                                        <td>RxJS Observable</td>
                                        <td>Provides operators for debouncing and throttling.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Global State</th>
                                        <td>Signals</td>
                                        <td>Easier for various components to read/write without complex streams.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p>Warning: Do not create a <code>toObservable</code> inside a loop or a frequently called
                            method. Like
                            <code>effect()</code>, <code>toObservable</code> must be called in an injection context
                            (like the constructor) or have
                            an explicit <code>Injector</code> passed to it. Creating subscriptions repeatedly can lead
                            to severe
                            memory leaks and performance degradation.
                        </p>
                    </section>

                    <section class="docs-section" id="item-3-4">
                        <p class="h3">Change Detection Strategy (OnPush vs Default)</p>
                        <p>Change Detection is the process by which Angular synchronizes the state of the application
                            with the user interface. It determines when a component’s data has changed and re-renders
                            the template to reflect those changes. By default, Angular is conservative; it runs change
                            detection on the entire component tree whenever any event occurs (such as a click, a timer,
                            or an HTTP response). However, as applications scale, this "check-everything" approach can
                            lead to performance bottlenecks.
                        </p>
                        <p>Angular provides two primary strategies for change detection: Default and OnPush.
                            Understanding the technical difference between these two is the key to building
                            high-performance, industrial-grade Angular applications.
                        </p>
                        <p class="h5">The Default Strategy (CheckAlways)</p>
                        <p>In the Default strategy, Angular makes no assumptions about when a component needs to be
                            updated. Whenever any asynchronous event occurs in the application, Angular performs a
                            "dirty check" on every component in the tree, starting from the root. It compares the
                            current values in the template with the previous values. If it finds a difference, it
                            updates the DOM.
                        </p>
                        <p>While this is highly developer-friendly because "things just work," it can be inefficient.
                            Even if a specific component’s data has not changed, Angular will still execute its change
                            detection logic and re-evaluate its template expressions.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-default-cd',
  standalone: true,
  // ChangeDetectionStrategy.Default is the implicit default
  template: `
    &lt;div&gt;
      &lt;h2&gt;{{ user.name }}&lt;/h2&gt;
      &lt;button (click)="noop()"&gt;Trigger CD&lt;/button&gt;
    &lt;/div&gt;
  `
})
export class DefaultComponent {
  user = { name: 'John Doe' };

  noop() {
    // Even if this function does nothing, Angular will re-check 
    // this component and all its children.
  }
}
</code></pre>
                        <p class="h5">The OnPush Strategy (CheckOnce)</p>
                        <p>The OnPush strategy tells Angular that the component only depends on its Inputs and Signals.
                            When a component is marked as <code>OnPush</code>, Angular will skip change detection for
                            that component
                            and its entire subtree unless specific "trigger" conditions are met. This drastically
                            reduces the number of checks performed across the application.
                        </p>
                        <p>To use this strategy, you must set the <code>changeDetection</code> property in the
                            <code>@Component</code> decorator
                            to <code>ChangeDetectionStrategy.OnPush</code>.
                        </p>

                        <pre><code class="language-javascript">import { Component, Input, ChangeDetectionStrategy } from '@angular/core';

@Component({
  selector: 'app-on-push-cd',
  standalone: true,
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    &lt;div&gt;
      &lt;h2&gt;User: {{ name }}&lt;/h2&gt;
    &lt;/div&gt;
  `
})
export class OnPushComponent {
  @Input() name: string = '';
}
</code></pre>
                        <p class="h5">When does OnPush trigger a refresh?</p>
                        <p>A component using <code>OnPush</code> will only update its view in the following specific
                            scenarios:</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Trigger</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Input Reference Change</th>
                                        <td>The <code>@Input</code> property receives a new object reference (not just a
                                            mutation of a property).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Event Originates Here</th>
                                        <td>A DOM event (like a click) is fired from within the component or its
                                            children.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Signal Update</th>
                                        <td>A <strong>Signal</strong> read within the template is updated.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Manual Trigger</th>
                                        <td>The developer explicitly calls <code>markForCheck()</code> via the
                                            <code>ChangeDetectorRef</code>.
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Async Pipe</th>
                                        <td>The <code>AsyncPipe</code> emits a new value from an Observable or Promise.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Technical Comparison: Default vs. OnPush</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Default Strategy</th>
                                        <th scope="col">OnPush Strategy</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Verification</th>
                                        <td>Checks every component on every event.</td>
                                        <td>Checks only when explicitly triggered.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Performance</th>
                                        <td>Lower (O(N) where N is component count).</td>
                                        <td>Higher (skips entire branches of the tree).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Predictability</th>
                                        <td>High; UI always matches data.</td>
                                        <td>Requires strict adherence to Immutability.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Best For</th>
                                        <td>Small apps or simple components.</td>
                                        <td>Complex UIs, large lists, and performance-critical apps.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">The Role of Immutability</p>
                        <p>The <code>OnPush</code> strategy relies heavily on Immutability. Because Angular only checks
                            if the object reference has changed for <code>@Input</code> properties, mutating a property
                            inside an object will not trigger an update.
                        </p>
                        <pre><code class="language-javascript">// PARENT COMPONENT LOGIC
user = { name: 'Alice' };

// ❌ This will NOT trigger OnPush change detection in child
updateUserMutation() {
  this.user.name = 'Bob'; 
}

// ✅ This WILL trigger OnPush change detection in child
updateUserImmutable() {
  this.user = { ...this.user, name: 'Bob' }; 
}
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>With the introduction of Signals, the complexity of managing <code>OnPush</code> is
                                    significantly reduced. Signals automatically notify Angular when they change,
                                    meaning a component can stay in <code>OnPush</code> mode while remaining perfectly
                                    reactive without requiring the developer to manually manage object references.</p>
                            </div>
                        </div>
                        <p class="h5">Manual Control with ChangeDetectorRef</p>
                        <p>In advanced scenarios, you might need to control the change detection cycle manually using
                            the <code>ChangeDetectorRef</code> service.
                        </p>
                        <ul>
                            <li><code>markForCheck()</code>: Schedules the component to be checked in the next cycle
                                (standard for
                                OnPush).
                            </li>
                            <li><code>detectChanges()</code>: Synchronously triggers change detection for this component
                                and its
                                children right now.
                            </li>
                            <li><code>detach()</code> / <code>reattach()</code>: Completely removes a component from the
                                change detection tree for
                                extreme optimization.
                            </li>
                        </ul>
                    </section>
                </article>

                <article class="docs-article" id="section-4">
                    <header class="docs-header">
                        <p class="h2 docs-heading">Section 4: Directives & Pipes</p>
                    </header>
                    <hr>
                    <section class="docs-section" id="item-4-1">
                        <p class="h3">Built-in Directives (ngClass, ngStyle)</p>
                        <p>Directives are classes that add additional behavior to elements in your Angular applications.
                            While components are technically directives with templates, Attribute Directives are used to
                            manage the appearance and behavior of existing DOM elements. The two most frequently used
                            built-in attribute directives are <code>ngClass</code> and <code>ngStyle</code>. These allow
                            you to dynamically add,
                            remove, or modify CSS classes and inline styles based on the state of your component logic.
                        </p>
                        <p>By using these directives, you move away from manual DOM manipulation (like
                            <code>element.classList.add()</code>) and instead adopt a declarative approach where the
                            view
                            automatically reflects the underlying data model.
                        </p>
                        <p class="h5">Dynamic Styling with ngClass</p>
                        <p>The <code>ngClass</code> directive allows you to add or remove multiple CSS classes
                            simultaneously. While
                            you can use standard property binding for a single class (e.g.,
                            <code>[class.active]="isActive"</code>),
                            <code>ngClass</code> is the preferred tool for managing complex sets of classes. It accepts
                            an object, an
                            array, or a string.
                        </p>
                        <p>The most powerful usage is the Object Literal syntax, where the keys are the class names and
                            the values are the boolean conditions that determine whether that class should be applied.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-status-box',
  standalone: true,
  imports: [CommonModule],
  template: `
    &lt;div [ngClass]="{
      'box-active': isActive,
      'box-error': hasError,
      'box-disabled': isDisabled
    }"&gt;
      Content Status: {{ status }}
    &lt;/div&gt;
    
    &lt;button (click)="toggleError()"&gt;Toggle Error State&lt;/button&gt;
  `,
  styles: [`
    .box-active { border: 2px solid blue; }
    .box-error { background-color: #ffdce0; color: #af0000; }
    .box-disabled { opacity: 0.5; pointer-events: none; }
  `]
})
export class StatusBoxComponent {
  isActive = true;
  hasError = false;
  isDisabled = false;
  status = 'Operating';

  toggleError() {
    this.hasError = !this.hasError;
    this.status = this.hasError ? 'System Failure' : 'Operating';
  }
}
</code></pre>
                        <p class="h5">Inline Styling with ngStyle</p>
                        <p>The <code>ngStyle</code> directive allows you to set multiple inline styles dynamically. Like
                            <code>ngClass</code>, it is most effective when used with an object where the keys are CSS
                            property names and the values are the expressions that evaluate to style values.
                        </p>
                        <p>This directive is particularly useful for styles that change frequently based on numerical
                            data or user input, such as the width of a progress bar, the coordinates of a draggable
                            element, or a user-selected theme color.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-progress-bar',
  standalone: true,
  imports: [CommonModule],
  template: `
    &lt;div class="progress-container"&gt;
      &lt;div [ngStyle]="{
        'width': progress + '%',
        'background-color': progress &gt; 80 ? 'red' : 'green',
        'transition': 'width 0.3s ease'
      }" class="bar"&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;input type="range" [(ngModel)]="progress" min="0" max="100"&gt;
  `,
  styles: [`
    .progress-container { width: 100%; height: 20px; background: #eee; }
    .bar { height: 100%; }
  `]
})
export class ProgressBarComponent {
  progress = 50;
}
</code></pre>
                        <p class="h5">Technical Comparison: Attribute Binding vs. Directives</p>
                        <p>Angular provides multiple ways to style elements. Choosing the right one depends on the
                            complexity of the logic and the number of properties being manipulated.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Method</th>
                                        <th scope="col">Syntax</th>
                                        <th scope="col">Best Use Case</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Class Binding</th>
                                        <td><code>[class.name]="bool"</code></td>
                                        <td>Toggling a <strong>single</strong> specific class.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">ngClass</th>
                                        <td><code>[ngClass]="{...}"</code></td>
                                        <td>Toggling <strong>multiple</strong> classes based on complex logic.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Style Binding</th>
                                        <td><code>[style.width.px]="val"</code></td>
                                        <td>Setting a <strong>single</strong> specific style property (with units).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">ngStyle</th>
                                        <td><code>[ngStyle]="{...}"</code></td>
                                        <td>Setting <strong>multiple</strong> inline styles dynamically.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>For simple class or style toggles, the standard property binding (e.g.,
                                    <code>[class.is-valid]="valid"</code>) is slightly more performant and cleaner than
                                    <code>ngClass</code>. Use
                                    <code>ngClass</code> and <code>ngStyle</code> only when you are managing a
                                    collection of styles or classes
                                    together.
                                </p>
                            </div>
                        </div>
                        <p class="h5">Key Technical Details & Units</p>
                        <p>When using <code>ngStyle</code>, you must ensure that values requiring units (like
                            <code>px</code>,<code> %</code>, or <code>em</code>) include
                            them. You can either append the unit in the string value or use the specific Angular style
                            binding extension.
                        </p>
                        <ul>
                            <li>String value: <code>'width': progress + 'px'</code></li>
                            <li>Binding extension: <code>[style.width.px]="progress"</code></li>
                        </ul>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">ngClass Behavior</th>
                                        <th scope="col">ngStyle Behavior</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Initial Values</th>
                                        <td>Merges with existing <code>class</code> attribute.</td>
                                        <td>Merges with existing <code>style</code> attribute.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Null/Undefined</th>
                                        <td>Removes the class/style if the value is null.</td>
                                        <td>Removes the specific style property if null.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Cleanup</th>
                                        <td>Automatically removes classes when conditions fail.</td>
                                        <td>Automatically removes inline styles when they are no longer provided.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p>Warning: Avoid using <code>ngStyle</code> to define large amounts of static CSS. Inline
                            styles have the
                            highest specificity and are harder to override via external stylesheets. Always prefer
                            <code>ngClass</code> with defined CSS classes in your component's stylesheet to maintain a
                            clean
                            separation between logic and presentation.
                        </p>
                    </section>

                    <section class="docs-section" id="item-4-2">
                        <p class="h3">Attribute Directives (Custom)</p>
                        <p>While built-in directives like <code>ngClass</code> handle common styling tasks, Custom
                            Attribute
                            Directives allow you to create reusable behaviors that can be applied to any DOM element. An
                            attribute directive changes the appearance or behavior of an element, component, or another
                            directive. Technically, a directive is a class decorated with the <code>@Directive</code>
                            decorator,
                            which provides metadata to Angular identifying the HTML selector used to trigger the
                            directive's logic.
                        </p>
                        <p>Custom directives are essential for implementing low-level DOM interactions—such as handling
                            hover effects, managing focus, or restricting input characters—that need to be shared across
                            multiple components without duplicating logic.
                        </p>
                        <p class="h5">Creating a Custom Directive</p>
                        <p>To create a directive, you define a class and use the <code>@Directive</code> decorator. The
                            most critical
                            part of the metadata is the <code>selector</code>. By convention, attribute directive
                            selectors are
                            wrapped in square brackets <code>[]</code>, which tells Angular to look for this name as an
                            attribute on
                            an HTML element.
                        </p>
                        <p>To interact with the host element, you typically inject ElementRef (to access the DOM
                            element) and Renderer2 (to perform DOM manipulations safely across different platforms).
                        </p>
                        <pre><code class="language-javascript">import { Directive, ElementRef, Renderer2, OnInit, Input } from '@angular/core';

@Directive({
  selector: '[appHighlight]', // Attribute selector
  standalone: true
})
export class HighlightDirective implements OnInit {
  @Input() highlightColor = 'yellow';
  @Input() defaultColor = 'transparent';

  constructor(private el: ElementRef, private renderer: Renderer2) {}

  ngOnInit() {
    // Set initial background color safely using Renderer2
    this.renderer.setStyle(this.el.nativeElement, 'backgroundColor', this.defaultColor);
  }
}
</code></pre>
                        <p class="h5">Handling User Events with HostListener</p>
                        <p>A directive often needs to respond to events triggered by the user on the host element. The
                            <code>@HostListener</code> decorator allows you to subscribe to events of the DOM element
                            that hosts the
                            directive. This is a declarative and memory-safe way to handle events like
                            <code>mouseenter</code>,
                            <code>mouseleave</code>, or <code>click</code>.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Decorator</th>
                                        <th scope="col">Purpose</th>
                                        <th scope="col">Example</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>@HostListener</strong></td>
                                        <td>Listens for DOM events on the host element.</td>
                                        <td><code>@HostListener('mouseenter')</code></td>
                                    </tr>
                                    <tr>
                                        <td><strong>@HostBinding</strong></td>
                                        <td>Binds a host element property to a directive property.</td>
                                        <td><code>@HostBinding('style.border')</code></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">import { Directive, ElementRef, HostListener, Renderer2, Input } from '@angular/core';

@Directive({
  selector: '[appHoverShadow]',
  standalone: true
})
export class HoverShadowDirective {
  @Input() shadowColor = 'rgba(0,0,0,0.5)';

  constructor(private el: ElementRef, private renderer: Renderer2) {}

  @HostListener('mouseenter') onMouseEnter() {
    this.setShadow(`0 4px 8px ${this.shadowColor}`);
  }

  @HostListener('mouseleave') onMouseLeave() {
    this.setShadow('none');
  }

  private setShadow(shadow: string) {
    this.renderer.setStyle(this.el.nativeElement, 'boxShadow', shadow);
    this.renderer.setStyle(this.el.nativeElement, 'transition', '0.3s');
  }
}
</code></pre>
                        <p class="h5">Passing Data to Directives</p>
                        <p>Custom directives can receive data through <code>@Input</code> properties, just like
                            components. If you want to pass a value directly to the directive using its selector name,
                            you can alias the input property to match the selector.
                        </p>
                        <pre><code class="language-javascript">// Inside the directive class
@Input('appHighlight') color = 'yellow';

// Usage in HTML
&lt;p [appHighlight]="'cyan'"&gt;Hover over me!&lt;/p&gt;
</code></pre>
                        <p class="h5">Directive Metadata and Configuration</p>
                        <p>When defining a directive, several properties in the decorator control how it interacts with
                            the application.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Property</th>
                                        <th scope="col">Type</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><strong>selector</strong></th>
                                        <td>string</td>
                                        <td>The CSS selector that identifies the directive in a template.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>standalone</strong></th>
                                        <td>boolean</td>
                                        <td>If true, the directive can be imported directly into components.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>providers</strong></th>
                                        <td>array</td>
                                        <td>Allows the directive to provide its own services.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>exportAs</strong></th>
                                        <td>string</td>
                                        <td>Defines a name that can be used to export the directive into a local
                                            template variable.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p> Always use Renderer2 instead of direct element manipulation (e.g.,
                                    <code>this.el.nativeElement.style.color = 'red'</code>). Renderer2 provides an
                                    abstraction layer
                                    that ensures your code works correctly in environments where the DOM might not be
                                    available, such as Server-Side Rendering (SSR) or Web Workers.
                                </p>
                            </div>
                        </div>
                        <p class="h5">Best Practices for Directives</p>
                        <ol>
                            <li>Prefixing: Always use a custom prefix for your directive selectors (e.g.,
                                <code>appHighlighter</code>
                                instead of just <code>highlight</code>) to avoid collisions with standard HTML
                                attributes or
                                third-party libraries.
                            </li>
                            <li>Statelessness: Try to keep directives focused on DOM behavior. If you find yourself
                                adding complex business logic, that logic likely belongs in a Service.
                            </li>
                            <li>Encapsulation: Use <code>@HostBinding</code> for simple property updates as it is more
                                concise than
                                calling <code>Renderer2</code> manually in every method.
                            </li>
                        </ol>
                        <p>Warning: Be careful when using <code>@HostListener</code> on events that fire frequently,
                            such as <code>scroll</code>
                            or <code>mousemove</code>. Since these events trigger Angular's change detection cycle by
                            default, they
                            can cause performance issues. For high-frequency events, consider running the logic outside
                            of Angular's zone using <code>NgZone.runOutsideAngular()</code>.
                        </p>
                    </section>

                    <section class="docs-section" id="item-4-3">
                        <p class="h3">Structural Directives (Custom)</p>
                        <p>Structural directives are responsible for shaping or reshaping the DOM's structure, typically
                            by adding, removing, or manipulating elements. Unlike attribute directives, which only
                            change the appearance or behavior of a single element, structural directives affect the
                            layout of the entire DOM branch. You can easily recognize them in templates by the asterisk
                            (<code>*</code>) prefix, such as <code>*ngIf</code> or <code>*ngFor</code>.
                        </p>
                        <p>Technically, the <code>*</code> is syntactic sugar that wraps the host element in an
                            <code>&lt;ng-template&gt;</code>. When you create a custom structural directive, you are
                            essentially defining the logic that determines when and how to "stamp out" that template
                            into the DOM using a View Container.
                        </p>
                        <p class="h5">Core Mechanics: TemplateRef and ViewContainerRef</p>
                        <p>To create a structural directive, your class requires access to two fundamental tools
                            provided by Angular's dependency injection:
                        </p>
                        <ol>
                            <li>TemplateRef: Represents the content inside the <code>&lt;ng-template&gt;</code> created
                                by the
                                asterisk syntax. It is the "blueprint" of what you want to render.
                            </li>
                            <li>ViewContainerRef: Represents a container where one or more views can be attached. It is
                                the "anchor" in the DOM where your blueprint will be physically placed.
                            </li>
                        </ol>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Tool</th>
                                        <th scope="col">Purpose</th>
                                        <th scope="col">Analogy</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">TemplateRef</th>
                                        <td>Holds the HTML structure to be rendered.</td>
                                        <td>The Stamp</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">ViewContainerRef</th>
                                        <td>Manages the location in the DOM.</td>
                                        <td>The Paper</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Creating a Custom "Unless" Directive</p>
                        <p>To understand the implementation, consider a directive that does the opposite of
                            <code>*ngIf</code>. We
                            will call it <code>*appUnless</code>. It should only render the content if the provided
                            condition is
                            false.
                        </p>
                        <pre><code class="language-javascript">import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appUnless]',
  standalone: true
})
export class UnlessDirective {
  private hasView = false;

  constructor(
    private templateRef: TemplateRef&lt;any&gt;,
    private viewContainer: ViewContainerRef
  ) {}

  @Input() set appUnless(condition: boolean) {
    // If condition is false and we haven't created the view yet, create it
    if (!condition &amp;&amp; !this.hasView) {
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.hasView = true;
    } 
    // If condition is true and the view exists, clear the container
    else if (condition &amp;&amp; this.hasView) {
      this.viewContainer.clear();
      this.hasView = false;
    }
  }
}
</code></pre>
                        <p class="h5">Usage in Template:</p>
                        <pre><code class="language-html">&lt;p *appUnless="isLoggedIn"&gt;Please log in to see this content.&lt;/p&gt;
</code></pre>
                        <p class="h5">De-sugaring the Asterisk</p>
                        <p>It is critical to understand what Angular does behind the scenes when it encounters the *.
                            The example above is transformed by the compiler into the following expanded form:
                        </p>
                        <pre><code class="language-html">&lt;ng-template [appUnless]="isLoggedIn"&gt;
  &lt;p&gt;Please log in to see this content.&lt;/p&gt;
&lt;/ng-template&gt;
</code></pre>
                        <p>Because of this transformation, the directive is applied to the
                            <code>&lt;ng-template&gt;</code>, not the <code>&lt;p&gt;</code>
                            tag. This is why we can inject <code>TemplateRef</code> into the directive’s constructor—the
                            directive is literally sitting on the template.
                        </p>
                        <p class="h5">Passing Context to the Template</p>
                        <p>Structural directives can also pass data to the template they are rendering. This is
                            how <code>*ngFor</code> provides variables like <code>item</code> or <code>index</code>. You
                            achieve this by passing a
                            context object as the second argument to <code>createEmbeddedView</code>.
                        </p>
                        <p>In the context object, the key <code>$implicit</code> is used for the default variable
                            (let-item),
                            while other keys map to specific named exports.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Context Key</th>
                                        <th scope="col">Template Variable</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><code>$implicit</code></th>
                                        <td><code>let-val</code></td>
                                        <td>The primary value passed to the template.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>customKey</code></th>
                                        <td><code>let-k=customKey</code></td>
                                        <td>A secondary value mapped to a specific name.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">// Inside a directive that provides the current time
this.viewContainer.createEmbeddedView(this.templateRef, {
  $implicit: 'User123',
  time: new Date().toLocaleTimeString()
});
</code></pre>
                        <p class="h5">Usage:</p>
                        <pre><code class="language-html">&lt;div *appUserTime="let user; let t = time"&gt;
  Hello {{ user }}, the time is {{ t }}.
&lt;/div&gt;
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>A single HTML element can only host one structural directive. If you attempt to use
                                    <code>*ngIf</code> and <code>*ngFor</code> on the same tag, Angular will throw an
                                    error. To solve this, wrap
                                    the element in a container like <code>&lt;ng-container&gt;</code> or a
                                    <code>div</code> to apply the second
                                    directive.
                                </p>
                            </div>
                        </div>
                        <p class="h5">Best Practices and Safety</p>
                        <ol>
                            <li>Naming Matching: The name of the <code>@Input</code> setter must match the directive's
                                selector
                                exactly for the asterisk syntax to work correctly.
                            </li>
                            <li>View Management: Always track whether the view is already created (using a boolean like
                                <code>hasView</code>) to prevent unnecessary DOM destructions and re-creations during
                                change
                                detection cycles.
                            </li>
                            <li>Cleanup: When the directive is destroyed, the <code>ViewContainerRef</code> is
                                automatically cleared,
                                so manual cleanup of the views is usually not required.
                            </li>
                        </ol>
                        <p>Warning: Be cautious with complex logic inside structural directive setters. Since setters
                            are called during every change detection cycle if the input changes, heavy computations can
                            lead to UI lag or "flickering" if the DOM is cleared and re-rendered too frequently.
                        </p>
                    </section>

                    <section class="docs-section" id="item-4-4">
                        <p class="h3">Pipes (Formatting Data)</p>
                        <p>Pipes are simple functions designed for use in template expressions to accept an input value
                            and return a transformed value. In Angular, data transformation should be decoupled from the
                            component's business logic. Instead of modifying the raw data in your TypeScript class just
                            for display purposes, you use pipes to format strings, currency amounts, dates, and other
                            data directly in the view.
                        </p>
                        <p>Pipes use the pipe character (<code>|</code>) within an interpolation or property binding
                            expression. They can be chained together to apply multiple transformations in sequence, and
                            they can accept optional parameters to fine-tune the output.
                        </p>
                        <p class="h5">Built-in Pipes</p>
                        <p>Angular provides a robust set of built-in pipes for common data transformations. These pipes
                            are optimized for performance and handle internationalization (i18n) automatically by using
                            the application's locale settings.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Pipe</th>
                                        <th scope="col">Purpose</th>
                                        <th scope="col">Example Syntax</th>
                                        <th scope="col">Output Example</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">DatePipe</th>
                                        <td>Formats date objects or strings.</td>
                                        <td><code>{{ today | date:'short' }}</code></td>
                                        <td>2/15/26, 3:43 PM</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">CurrencyPipe</th>
                                        <td>Formats numbers into currency strings.</td>
                                        <td><code>{{ 15 | currency:'EUR' }}</code></td>
                                        <td>€15.00</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">DecimalPipe</th>
                                        <td>Formats numbers with specific decimals.</td>
                                        <td><code>{{ 3.1415 | number:'1.1-2' }}</code></td>
                                        <td>3.14</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">PercentPipe</th>
                                        <td>Formats a number as a percentage.</td>
                                        <td><code>{{ 0.75 | percent }}</code></td>
                                        <td>75%</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">UpperCasePipe</th>
                                        <td>Transforms text to all upper case.</td>
                                        <td><code>{{ 'hi' | uppercase }}</code></td>
                                        <td>HI</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">JsonPipe</th>
                                        <td>Converts an object into a JSON string.</td>
                                        <td><code>{{ user | json }}</code></td>
                                        <td>{ "id": 1 ... }</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Chaining and Parameterization</p>
                        <p>You can pass parameters to a pipe by following the pipe name with a colon (:) and the
                            parameter value. If a pipe accepts multiple parameters, separate them with additional
                            colons. Furthermore, pipes can be chained to process data through a multi-stage pipeline.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-pipe-demo',
  standalone: true,
  imports: [CommonModule],
  template: `
    &lt;div class="product"&gt;
      &lt;h3&gt;Sale Price: {{ price | currency:'USD':'symbol':'1.0-0' }}&lt;/h3&gt;
      &lt;p&gt;Expired on: {{ expiryDate | date:'fullDate' | uppercase }}&lt;/p&gt;
      
      &lt;p&gt;Category: {{ category | lowercase | titlecase }}&lt;/p&gt;
    &lt;/div&gt;
  `
})
export class PipeDemoComponent {
  price = 1250.60;
  expiryDate = new Date(2026, 11, 25);
  category = 'ELECTRONICS_HARDWARE';
}   
</code></pre>
                        <p class="h5">Custom Pipes</p>
                        <p>When built-in pipes do not meet your requirements, you can create a custom pipe. A custom
                            pipe is a class decorated with <code>@Pipe</code> that implements the
                            <code>PipeTransform</code> interface. This
                            interface requires a <code>transform</code> method, which takes the input value and optional
                            arguments,
                            returning the transformed result.
                        </p>
                        <pre><code class="language-javascript">import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'appTruncate',
  standalone: true
})
export class TruncatePipe implements PipeTransform {
  // value: the data being piped in
  // limit: the first argument passed after the colon
  transform(value: string, limit: number = 20, suffix: string = '...'): string {
    if (!value) return '';
    return value.length &gt; limit 
      ? value.substring(0, limit) + suffix 
      : value;
  }
}
</code></pre>
                        <p class="h5">Usage in HTML:</p>
                        <pre><code class="language-html">
&lt;p&gt;{{ longDescription | appTruncate:50:' [Read More]' }}&lt;/p&gt;
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p> The <code>AsyncPipe</code> is one of the most important pipes in Angular. It
                                    automatically
                                    subscribes to an Observable or Promise and returns the latest value it has emitted.
                                    When the component is destroyed, it automatically unsubscribes to prevent memory
                                    leaks.</p>
                            </div>
                        </div>
                        <p class="h5">Pure vs. Impure Pipes</p>
                        <p>By default, pipes are pure. A pure pipe is only executed when Angular detects a "pure change"
                            to the input value. A pure change is either a change to a primitive input value (String,
                            Number, Boolean) or a changed object reference (Array, Object).
                        </p>
                        <p>If you mutate an internal property of an object or push an item into an array, a pure pipe
                            will not re-execute because the reference remains the same. An impure pipe, however, is
                            executed during every change detection cycle, regardless of whether the inputs changed.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Aspect</th>
                                        <th scope="col">Pure Pipe (Default)</th>
                                        <th scope="col">Impure Pipe</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Execution</th>
                                        <td>Only when input reference changes.</td>
                                        <td>Every change detection cycle.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Performance</th>
                                        <td>High (optimized).</td>
                                        <td>Potentially Low (can slow down UI).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">State</th>
                                        <td>Should be stateless.</td>
                                        <td>Can be stateful.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Use Case</th>
                                        <td>Formatting, simple math.</td>
                                        <td>Filtering arrays (where items change).</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p>To make a pipe impure, set the <code>pure</code> flag to <code>false</code> in the decorator:
                            <code>@Pipe({ name: 'myPipe',
                            pure: false })</code>.
                        </p>
                        <p>Warning: Avoid heavy computations or HTTP requests inside a pipe's <code>transform</code>
                            method. Because
                            pipes are called frequently within the template (especially if they are impure), expensive
                            logic can lead to severe UI lag and frame drops. For complex data processing, perform the
                            logic in the component's TypeScript class or a Service.
                        </p>
                    </section>

                    <section class="docs-section" id="item-4-5">
                        <p class="h3">Creating Custom Pipes</p>
                        <p>Custom pipes allow you to encapsulate reusable data transformation logic that isn't covered
                            by Angular's built-in set. Whether you need to format a specific business ID, mask sensitive
                            data, or perform complex string manipulation, custom pipes keep your templates clean and
                            your component logic focused on state management rather than formatting.
                        </p>
                        <p>A custom pipe is a TypeScript class decorated with the <code>@Pipe</code> decorator. To
                            ensure type safety
                            and proper integration, the class must implement the <code>PipeTransform</code> interface.
                        </p>
                        <p class="h5">The Anatomy of a Custom Pipe</p>
                        <p>The core of a pipe is the <code>transform</code> method. This method accepts the value to be
                            transformed
                            as its first argument, followed by any optional parameters.
                        </p>
                        <pre><code class="language-javascript">import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'appInitials',      // The name used in templates: {{ name | appInitials }}
  standalone: true          // Allows direct import without NgModules
})
export class InitialsPipe implements PipeTransform {
  /**
   * @param value The input string to transform
   * @param limit Optional parameter to limit number of initials returned
   */
  transform(value: string, limit: number = 2): string {
    if (!value) return '';

    return value
      .split(' ')
      .map(word =&gt; word[0])
      .join('')
      .toUpperCase()
      .substring(0, limit);
  }
}
</code></pre>
                        <p class="h5">Registering and Using the Pipe</p>
                        <p>In modern Angular, you use the <code>standalone: true</code> property. To use the pipe, you
                            must add it to
                            the <code>imports</code> array of the component where you intend to use it.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Component Step</th>
                                        <th scope="col">Action</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Import Class</th>
                                        <td>
                                            <code>import { InitialsPipe } from './initials.pipe';</code>
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Declare Usage</th>
                                        <td>
                                            Add <code>InitialsPipe</code> to the
                                            <code>@Component({ imports: [...] })</code> array.
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Apply in View</th>
                                        <td>
                                            Use the <code>|</code> pipe operator in your template.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Example Usage:</p>
                        <pre><code class="language-html">&lt;div class="avatar"&gt;{{ user.fullName | appInitials }}&lt;/div&gt;

&lt;span&gt;{{ jobTitle | appInitials:3 }}&lt;/span&gt;
</code></pre>
                        <p class="h5">Handling Complex Data Types</p>
                        <p>Pipes aren't limited to strings. They can handle objects and arrays. For instance, a common
                            use case is a pipe that extracts a specific property from an object or filters an array
                            based on a criteria.
                        </p>
                        <pre><code class="language-javascript">@Pipe({
  name: 'appPluck',
  standalone: true
})
export class PluckPipe implements PipeTransform {
  transform(objects: any[], key: string): any[] {
    return objects.map(obj =&gt; obj[key]);
  }
}
</code></pre>
                        <p class="h5">Best Practices for Custom Pipes</p>
                        <p>To maintain application performance and code quality, follow these guidelines when building
                            custom pipes:
                        </p>
                        <ul>
                            <li>Single Responsibility: Each pipe should do one thing well (e.g., formatting a phone
                                number).
                            </li>
                            <li>Handle Nulls: Always include a check for <code>null</code> or <code>undefined</code>
                                values at the beginning of
                                your <code>transform</code> method to prevent runtime errors.
                            </li>
                            <li>Type Safety: Use TypeScript generics or specific types for the <code>value</code> and
                                return type of
                                the <code>transform</code> method.
                            </li>
                            <li>Stay Pure: Keep pipes "pure" (default) whenever possible. Pure pipes are only
                                re-executed when the input reference changes, which is significantly better for
                                performance.
                            </li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>If you find yourself needing to inject a service into a pipe (e.g., a translation
                                    service), you can do so via the constructor. However, ensure the pipe remains
                                    performant, as it will be called frequently during change detection.</p>
                            </div>
                        </div>
                        <p class="h5">Technical Comparison: Pipe vs. Component Method</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Custom Pipe</th>
                                        <th scope="col">Component Method</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Reusability</th>
                                        <td>Highly reusable across any component.</td>
                                        <td>Restricted to the host component.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Performance</th>
                                        <td>Optimized; pure pipes skip re-execution if inputs match.</td>
                                        <td>Re-executes on every change detection cycle.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Readability</th>
                                        <td>Declarative and clean in templates.</td>
                                        <td>Can clutter templates with logic calls.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p>Warning: Do not use pipes to filter or sort large arrays if the pipe is marked as
                            <code>pure: false</code>
                            (impure). Because impure pipes run on every change detection cycle, sorting a list of 1,000
                            items multiple times per second will freeze the browser UI. In such cases, perform the
                            sorting in the component logic using Signals or RxJS.
                        </p>
                    </section>
                </article>

                <article class="docs-article" id="section-5">
                    <header class="docs-header">
                        <p class="h2 docs-heading">Section 5: Dependency Injection (DI)</p>
                    </header>
                    <hr>
                    <section class="docs-section" id="item-5-1">
                        <p class="h3">Understanding DI</p>
                        <p>Dependency Injection (DI) is a core design pattern in Angular and a fundamental pillar of its
                            architecture. In simple terms, DI is a coding pattern in which a class asks for dependencies
                            from external sources rather than creating them itself. Instead of a component manually
                            instantiating a service (e.g., <code>const service = new DataService()</code>), Angular's DI
                            system
                            "injects" the instance into the component.
                        </p>
                        <p>This approach promotes decoupling, making your code more modular, easier to test, and more
                            maintainable. By centralizing how objects are created, Angular can manage the lifecycle of
                            services and share single instances across multiple components.
                        </p>
                        <p class="h5">The Three Pillars of Angular DI</p>
                        <p>To understand how DI works in Angular, you must distinguish between the three main roles in
                            the process:
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Role</th>
                                        <th scope="col">Responsibility</th>
                                        <th scope="col">Analogy</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><strong>The Dependency</strong></th>
                                        <td>The object or service that needs to be used (the "What").</td>
                                        <td>The Tool</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>The Provider</strong></th>
                                        <td>A set of instructions telling the DI system how to create the dependency.
                                        </td>
                                        <td>The Instruction Manual</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>The Injector</strong></th>
                                        <td>The container that holds the instances and delivers them to classes.</td>
                                        <td>The Tool Distributor</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Providing a Service</p>
                        <p>In modern Angular, the preferred way to provide a service is using the
                            <code>providedIn: 'root'</code> metadata. This makes the service a Singleton, meaning only
                            one instance of the service
                            exists for the entire application. It also enables tree-shaking, which ensures the service
                            is excluded from the final production bundle if it is never used.
                        </p>
                        <pre><code class="language-javascript">import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root' // Tells Angular to provide this at the root level
})
export class LoggerService {
  log(message: string) {
    console.log(`[LOG]: ${message}`);
  }
}
</code></pre>
                        <p class="h5">Injecting a Dependency</p>
                        <p>There are two primary ways to inject a dependency into an Angular component or directive:
                        </p>
                        <p class="h5">1. Constructor Injection (Traditional)</p>
                        <p>This is the classic approach where you declare the dependency as a private parameter in the
                            class constructor.</p>
                        <pre><code class="language-javascript">export class MyComponent {
  constructor(private logger: LoggerService) {
    this.logger.log('Component initialized via Constructor DI');
  }
}
</code></pre>
                        <p class="h5">2. The <code>inject()</code> Function (Modern)</p>
                        <p>Introduced in recent versions, the <code>inject()</code> function allows you to inject
                            dependencies at the field level. This is often cleaner, especially when using functional
                            features or inheritance.
                        </p>
                        <pre><code class="language-javascript">import { Component, inject } from '@angular/core';

export class MyComponent {
  private logger = inject(LoggerService); // Cleaner field-level injection

  init() {
    this.logger.log('Component initialized via inject()');
  }
}
</code></pre>
                        <p class="h5">Hierarchical Injection (The Injector Tree)</p>
                        <p>Angular’s DI system is hierarchical. If a dependency isn't found in a component's local
                            injector, Angular looks up to the parent component's injector, and so on, until it reaches
                            the Root Injector.
                        </p>
                        <ul>
                            <li>Root Level: Service is a singleton shared by all.
                            </li>
                            <li>Component Level: Service is private to that component and its children; a new instance
                                is created for every instance of the component.
                            </li>
                        </ul>
                        <p class="h5">Benefits of Using DI</p>
                        <ul>
                            <li>Testability: You can easily swap a real service with a "Mock" or "Spy" during unit
                                testing without changing the component code.
                            </li>
                            <li>Reusability: Services can be reused across different components, reducing code
                                duplication.
                            </li>
                            <li>Memory Management: Angular handles the creation and destruction of service instances
                                automatically.
                            </li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Most services should be provided in <code> 'root'</code>. Only provide a service at
                                    the component level if you explicitly need a fresh, isolated instance of that
                                    service for every instance of that component.</p>
                            </div>
                        </div>
                        <p>Warning: Avoid creating circular dependencies (e.g., Service A injects Service B, and Service
                            B injects Service A). This will lead to a runtime error. If you encounter this, it is
                            usually a sign that common logic should be extracted into a third, shared service.
                        </p>
                    </section>

                    <section class="docs-section" id="item-5-2">
                        <p class="h3">Creating Injectable Services</p>
                        <p>In Angular, a Service is a class with a narrow, well-defined purpose. While components are
                            responsible for the UI and user experience, services are responsible for "everything
                            else"—fetching data from a server, validating user input, or logging messages to a console.
                            By moving this logic into services, you make your components lean and focused solely on
                            presenting data.
                        </p>
                        <p>To make a class "injectable" (capable of being managed by the DI system), you must decorate
                            it with the <code>@Injectable()</code> decorator.
                        </p>
                        <p class="h5">Anatomy of a Service</p>
                        <p>A service is a standard TypeScript class. The <code>@Injectable()</code> decorator provides
                            metadata that
                            tells Angular this class can be used by the Dependency Injection system. The
                            <code>providedIn</code>
                            property determines the scope of the service.
                        </p>
                        <pre><code class="language-javascript">import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root' // Available globally as a singleton
})
export class DataService {
  private items: string[] = ['Angular', 'Signals', 'RxJS'];

  getItems(): string[] {
    return this.items;
  }

  addItem(newItem: string): void {
    this.items.push(newItem);
  }
}
</code></pre>
                        <p class="h5">Scoping Your Services</p>
                        <p>Where you "provide" a service changes its lifecycle and visibility. Understanding scope is
                            critical for managing application state correctly.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Scope</th>
                                        <th scope="col">Configuration</th>
                                        <th scope="col">Lifecycle</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><strong>Global (Root)</strong></th>
                                        <td><code>providedIn: 'root'</code></td>
                                        <td>Created once (Singleton) and lasts for the entire app session. Supports
                                            tree-shaking.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>Component</strong></th>
                                        <td>
                                            <code>providers: [MyService]</code><br>
                                            in <code>@Component</code>
                                        </td>
                                        <td>Created when the component is initialized; destroyed when the component is
                                            destroyed.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>Lazy Module</strong></th>
                                        <td><code>providedIn: 'any'</code></td>
                                        <td>A separate instance is created for every lazy-loaded module that injects it.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Consuming a Service</p>
                        <p>Once a service is created and provided, a component can "consume" it by requesting it. The
                            most modern and flexible way to do this is using the <code>inject()</code> function.
                        </p>
                        <pre><code class="language-javascript">import { Component, inject } from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'app-item-list',
  standalone: true,
  template: `
    &lt;ul&gt;
      @for (item of items; track item) {
        &lt;li&gt;{{ item }}&lt;/li&gt;
      }
    &lt;/ul&gt;
  `
})
export class ItemListComponent {
  // Injecting the service
  private dataService = inject(DataService);
  
  // Accessing service data
  items = this.dataService.getItems();
}
</code></pre>
                        <p class="h5">Services with Dependencies</p>
                        <p>Services can also depend on other services. For example, a <code>UserService</code> might
                            need the
                            <code>HttpClient</code> to fetch data from an API. When injecting one service into another,
                            the
                            <code>@Injectable()</code> decorator is strictly required on the receiving class.
                        </p>
                        <pre><code class="language-javascript">@Injectable({ providedIn: 'root' })
export class UserService {
  // A service injecting another service (HttpClient)
  private http = inject(HttpClient);

  getUsers() {
    return this.http.get('/api/users');
  }
}
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Even if a service doesn't currently have dependencies, it is a best practice to
                                    always include the <code>@Injectable()</code> decorator. This ensures that if you
                                    add dependencies later, the DI system is already configured to handle them.</p>
                            </div>
                        </div>
                        <p class="h5">Best Practices for Services</p>
                        <ul>
                            <li>Keep it Stateless: Whenever possible, services should be stateless (functional). If a
                                service must hold state, consider using Signals within the service to make that state
                                reactive.
                            </li>
                            <li>Single Responsibility: A <code>LoggingService</code> should only log; it shouldn't also
                                be
                                responsible for user authentication.
                            </li>
                            <li>Tree-shakable Providers: Always prefer <code>providedIn: 'root'</code> over adding
                                services to a
                                <code>providers</code> array in a module, as this allows the Angular compiler to remove
                                the service
                                if it's never used, reducing your bundle size.
                            </li>
                        </ul>
                        <p>Warning: Never use the <code>new</code> keyword to create an instance of a service (e.g.,
                            <code>const s = new
                            DataService()</code>) inside a component. Doing so bypasses Angular's DI system, meaning
                            the
                            service won't have access to other injected dependencies (like <code>HttpClient</code>) and
                            you lose the
                            ability to easily mock the service for testing.
                        </p>
                    </section>

                    <section class="docs-section" id="item-5-3">
                        <p class="h3">Hierarchical Injectors</p>
                        <p>Angular’s Dependency Injection system is hierarchical. This means that injectors are
                            organized in a tree structure that parallels your component tree. When a component requests
                            a dependency, Angular doesn't just look in one place; it starts at the component's local
                            injector and bubbles up through the parent injectors until it finds a provider or reaches
                            the root.
                        </p>
                        <p>This hierarchy allows you to control the visibility and lifecycle of your services, enabling
                            patterns like shared singletons, isolated state, or specialized overrides for specific
                            branches of your UI.
                        </p>
                        <p class="h5">The Two Injector Hierarchies</p>
                        <p>Angular actually maintains two distinct injector trees. Understanding the difference is key
                            to advanced architecture:
                        </p>
                        <ol>
                            <li>Environment Injector Hierarchy: This contains services provided at the "Root" level or
                                within loaded routes/modules. These are typically application-wide singletons.
                            </li>
                            <li>Element Injector Hierarchy: This is created dynamically for every DOM element
                                (components and directives). This is where "Component-level" services live.
                            </li>
                        </ol>
                        <p class="h5">Resolution Rules</p>
                        <p>When a component or directive requests a dependency, Angular follows a strict lookup path:
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Order</th>
                                        <th scope="col">Injector Level</th>
                                        <th scope="col">Behavior</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">1</th>
                                        <td><strong>Element Injector</strong></td>
                                        <td>Looks at the current component's <code>providers</code> array.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">2</th>
                                        <td><strong>Parent Element</strong></td>
                                        <td>Searches up the DOM tree through parent components.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">3</th>
                                        <td><strong>Environment/Root</strong></td>
                                        <td>Searches the application-wide providers (e.g.,
                                            <code>providedIn: 'root'</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row">4</th>
                                        <td><strong>Null Injector</strong></td>
                                        <td>If still not found, Angular throws a "No provider found" error (unless
                                            marked optional).</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Use Cases for Hierarchical DI</p>
                        <p>While <code>providedIn: 'root'</code> is the standard for 90% of services, providing services
                            at the
                            component level is powerful for specific scenarios:
                        </p>
                        <ul>
                            <li>State Isolation: If you have a complex <code>FileEditorComponent</code>, you might
                                provide a
                                <code>SelectionService</code> at the component level. Every time you open a new editor
                                tab, it gets
                                its own fresh, isolated instance of the service.
                            </li>
                            <li>Component-Specific Configuration: Providing a configuration service at a parent level to
                                modify the behavior of all its children.
                            </li>
                            <li>Encapsulation: Keeping services private to a specific UI feature so they aren't
                                accessible (or accidentally modified) by the rest of the app.
                            </li>
                        </ul>
                        <pre><code class="language-javascript">@Component({
  selector: 'app-parent',
  standalone: true,
  // This service is now unique to this instance of Parent and its children
  providers: [LocalStateService], 
  template: `&lt;app-child&gt;&lt;/app-child&gt;`
})
export class ParentComponent {}
</code></pre>
                        <p class="h5">Resolution Modifiers</p>
                        <p>You can control how Angular searches the hierarchy using Resolution Modifiers. These are
                            decorators (or options in <code>inject()</code>) that tell the DI system to stop searching
                            or handle missing providers gracefully.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Modifier</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><code>@Optional()</code></th>
                                        <td>Returns <code>null</code> instead of throwing an error if the provider is
                                            missing.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>@Self()</code></th>
                                        <td>Only looks in the local element injector; does not bubble up.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>@SkipSelf()</code></th>
                                        <td>Starts the search at the parent injector, ignoring the local one.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><code>@Host()</code></th>
                                        <td>Stops the search at the "Host" component (the boundary of the current
                                            template).</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Modern Syntax Example:</p>
                        <pre><code class="language-javascript">// Using the inject() function with modifiers
private localService = inject(LocalService, { self: true, optional: true });
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>When a service is provided in a component's <code>providers</code> array, that
                                    service instance is
                                    tied to the component's lifecycle. When the component is destroyed, the service
                                    instance is also destroyed, triggering its <code>ngOnDestroy</code> hook if it
                                    implements it.</p>
                            </div>
                        </div>
                        <p>Warning: Be careful not to accidentally provide a service in multiple places. If you have a
                            service marked <code>providedIn: 'root'</code> but also list it in a component's
                            <code>providers: []</code> array, that
                            component (and its children) will receive a new, separate instance, potentially causing bugs
                            if you expected a global singleton.
                        </p>
                    </section>

                    <section class="docs-section" id="item-5-4">
                        <p class="h3">Injection Tokens & Providers</p>
                        <p>While most dependencies in Angular are classes (like services), there are many situations
                            where you need to inject things that aren't classes—such as configuration objects, constant
                            strings, or external API keys. Furthermore, you may want to swap the implementation of a
                            service without changing the code of the components that use it. Injection Tokens and
                            Providers give you the power to define exactly what is injected and how it is created.
                        </p>
                        <p class="h5">1. Injection Tokens</p>
                        <p>An <code>InjectionToken</code> is an object used as a lookup key in the DI system when the
                            dependency is
                            not a class. Since interfaces do not exist at runtime in JavaScript, you cannot use them as
                            DI tokens. Instead, you create an <code>InjectionToken</code> to represent that dependency.
                        </p>
                        <pre><code class="language-javascript">import { InjectionToken } from '@angular/core';

// 1. Define the shape of the dependency
export interface AppConfig {
  apiUrl: string;
  retryCount: number;
}

// 2. Create the token
export const APP_CONFIG = new InjectionToken&lt;AppConfig&gt;('app.config');
</code></pre>
                        <p class="h5">Usage:</p>
                        <pre><code class="language-javascript">
// Injecting the token using the inject() function
const config = inject(APP_CONFIG);
</code></pre>
                        <p class="h5">2. Provider Recipes</p>
                        <p>When you provide a dependency, you are giving the DI system a "recipe." While the shorthand
                            <code>providers: [MyService]</code> is common, the expanded object syntax reveals the full
                            flexibility of the system.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Provider Key</th>
                                        <th scope="col">Description</th>
                                        <th scope="col">Use Case</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>useClass</code></td>
                                        <td>Instantiates a specific class.</td>
                                        <td>Swapping a real service for a Mock version.</td>
                                    </tr>
                                    <tr>
                                        <td><code>useValue</code></td>
                                        <td>Uses a static value or object.</td>
                                        <td>Injecting configuration constants or API keys.</td>
                                    </tr>
                                    <tr>
                                        <td><code>useExisting</code></td>
                                        <td>Maps one token to another existing token.</td>
                                        <td>Creating an alias for an existing service.</td>
                                    </tr>
                                    <tr>
                                        <td><code>useFactory</code></td>
                                        <td>Uses a function to create the dependency.</td>
                                        <td>Dynamic creation based on other services.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">useClass: Swapping Implementations</p>
                        <pre><code class="language-javascript">providers: [
  { provide: LoggerService, useClass: AdvancedLoggerService }
]
// Any component asking for LoggerService now gets AdvancedLoggerService.
</code></pre>
                        <p class="h5">useValue: Injecting Constants</p>
                        <pre><code class="language-javascript">providers: [
  { provide: APP_CONFIG, useValue: { apiUrl: 'https://api.v1.com', retryCount: 3 } }
]
</code></pre>
                        <p class="h5">useFactory: Dynamic Dependencies</p>
                        <p>Sometimes you need logic to decide how a service is built. <code>useFactory</code> takes a
                            function and an
                            optional <code>deps</code> array of other dependencies that the factory needs.
                        </p>
                        <pre><code class="language-javascript">providers: [
  {
    provide: DATA_SERVICE,
    useFactory: (http: HttpClient) =&gt; {
      return isDevMode() ? new DevDataService(http) : new ProdDataService(http);
    },
    deps: [HttpClient]
  }
]
</code></pre>
                        <p class="h5">3. Multi-Providers</p>
                        <p>By default, a provider replaces any previous provider for the same token. However, if you set
                            <code>multi: true</code>, Angular will instead collect all provided values for that token
                            into an array. This is how Angular handles "plug-in" architectures, like HTTP Interceptors.
                        </p>
                        <pre><code class="language-javascript">providers: [
  { provide: APP_INITIALIZER, useValue: () =&gt; console.log('Init 1'), multi: true },
  { provide: APP_INITIALIZER, useValue: () =&gt; console.log('Init 2'), multi: true }
]
// APP_INITIALIZER now injects as an array: [fn1, fn2]
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>When using <code>InjectionToken</code>, you can also provide it at the root level
                                    directly within the token definition. This is the modern, tree-shakable way to
                                    provide constants.</p>
                            </div>
                        </div>
                        <pre><code class="language-javascript">export const API_URL = new InjectionToken&lt;string&gt;('api', {
  providedIn: 'root',
  factory: () =&gt; 'https://api.example.com'
});
</code></pre>
                        <p>Warning: Always use <code>InjectionToken</code> for strings or objects. Never use a plain
                            string as a provider key (e.g.,
                            <code>{ provide: 'API_URL', ... }</code>). String tokens can cause name collisions if two
                            different parts of your app (or a third-party library) use the same string, leading to
                            hard-to-debug "last-one-wins" errors.
                        </p>
                    </section>
                </article>

                <article class="docs-article" id="section-6">
                    <header class="docs-header">
                        <p class="h2 docs-heading">Section 6: Routing & Navigation</p>
                    </header>
                    <hr>
                    <section class="docs-section" id="item-6-1">
                        <p class="h3">Defining Routes</p>
                        <p>Angular's Router is a powerful navigation engine that allows you to transform a Single Page
                            Application (SPA) into a multi-view experience. It maps specific browser URL paths to
                            specific components. When a user navigates to a URL, the Router intercepts the request and
                            renders the corresponding component without refreshing the entire page.
                        </p>
                        <p>In modern Angular applications, routes are typically defined as a constant array of
                            <code>Route</code> objects and passed to the <code>provideRouter</code> function in the
                            application configuration.
                        </p>
                        <p class="h5">Basic Route Configuration</p>
                        <p>A standard route object requires at least two properties: <code>path</code> (the URL segment)
                            and <code>component</code> (the class to display).
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Property</th>
                                        <th scope="col">Type</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><strong>path</strong></th>
                                        <td><code>string</code></td>
                                        <td>The URL segment (do not include the leading slash).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>component</strong></th>
                                        <td><code>Type&lt;any&gt;</code></td>
                                        <td>The component class that should be rendered.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>title</strong></th>
                                        <td><code>string</code></td>
                                        <td>(Optional) Automatically updates the browser tab title.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>redirectTo</strong></th>
                                        <td><code>string</code></td>
                                        <td>Redirects a path to another defined route.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>pathMatch</strong></th>
                                        <td><code>'full' | 'prefix'</code></td>
                                        <td>Determines how the router matches the URL to the path.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">// app.routes.ts
import { Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';

export const routes: Routes = [
  { path: '', redirectTo: 'home', pathMatch: 'full' }, // Default redirect
  { path: 'home', component: HomeComponent, title: 'My App - Home' },
  { path: 'about', component: AboutComponent, title: 'My App - About Us' },
  { path: '**', component: NotFoundComponent } // Wildcard for 404 pages
];
</code></pre>
                        <p class="h5">The Router Outlet</p>
                        <p>The <code>&lt;router-outlet&gt;</code> is a directive that acts as a placeholder. It tells
                            the Angular Router exactly where to "plug in" the component that matches the current URL.
                            Usually, you place this in your <code>AppComponent</code> template, often surrounded by a
                            global header and footer.
                        </p>
                        <pre><code class="language-html">&lt;nav&gt;
  &lt;a routerLink="/home"&gt;Home&lt;/a&gt;
  &lt;a routerLink="/about"&gt;About&lt;/a&gt;
&lt;/nav&gt;

&lt;main&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
&lt;/main&gt;
</code></pre>
                        <p class="h5">Route Matching Strategies</p>
                        <p>Angular provides two ways to match a URL to a path. This is crucial for the empty string
                            <code>''</code> path used for homepages.
                        </p>
                        <ul>
                            <li><code>pathMatch: 'prefix'</code> (Default): Matches if the URL starts with the path. For
                                example, '' matches everything.
                            </li>
                            <li><code>pathMatch: 'full'</code>: Matches only if the URL is exactly the path. Always use
                                this for empty paths to avoid infinite redirect loops.
                            </li>
                        </ul>
                        <p class="h5">Handling "Not Found" (Wildcard) Routes</p>
                        <p>The wildcard route (**) matches any URL that does not match an earlier route in the array.
                        </p>
                        <p>Critical Rule: The Router matches routes linearly from top to bottom. You must always place
                            the wildcard route at the very end of your routes array. If you place it at the top, it will
                            match every request, and your other routes will never be reached.
                        </p>
                        <p class="h5">Organizing with Lazy Loading</p>
                        <p>For large applications, you don't want to load every component at startup. Lazy Loading
                            allows you to load parts of your application only when the user navigates to that specific
                            route. This significantly improves the initial load time.
                        </p>
                        <pre><code class="language-javascript">export const routes: Routes = [
  {
    path: 'admin',
    // Component is only downloaded when /admin is visited
    loadComponent: () =&gt; import('./admin/admin.component').then(m =&gt; m.AdminComponent)
  }
];
</code></pre>
                        <p>Warning: Ensure your <code>path</code> strings do not start with a forward slash
                            <code>/</code>. For example, use <code>path: 'details'</code>, not
                            <code>path: '/details'</code>. The router handles the slashes automatically; adding your own
                            will result in routes that never match.
                        </p>
                    </section>
                    <section class="docs-section" id="item-6-2">
                        <p class="h3">Router Outlet & Links</p>
                        <p>Once your routes are defined, you need a way to display the components and allow users to
                            navigate between them. Angular provides two primary directives for this: RouterOutlet for
                            rendering and RouterLink for navigation. These directives transform your static HTML into a
                            dynamic, single-page navigation system.</p>
                        <p class="h5">The Router Outlet (<code>&lt;router-outlet&gt;</code>)</p>
                        <p>The <code>RouterOutlet</code> acts as a dynamic placeholder. When the user navigates to a
                            route, the router identifies the associated component and instantiates it immediately after
                            this tag.
                        </p>
                        <ul>
                            <li>Location: Typically placed in <code>app.component.html</code> to define the main content
                                area.
                            </li>
                            <li>Multiple Outlets: While most apps use one, you can have "named" outlets for complex
                                layouts (like a sidebar and a main view changing independently).
                            </li>
                        </ul>
                        <pre><code class="language-html">&lt;header&gt;My Application&lt;/header&gt;

&lt;main&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
&lt;/main&gt;

&lt;footer&gt;© 2026&lt;/footer&gt;
</code></pre>
                        <p class="h5">Declarative Navigation: <code>RouterLink</code></p>
                        <p>To navigate between views, you should avoid using standard <code>href</code> attributes on
                            <code>&lt;a&gt;</code> tags. A standard <code>href</code> causes the browser to reload the
                            entire page, destroying the application state. Instead, use the <code>routerLink</code>
                            directive. This intercepts the click, updates the URL, and tells the Router to swap
                            components—all without a page refresh.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Syntax</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Basic Link</strong></td>
                                        <td><code>routerLink="/home"</code></td>
                                        <td>Navigates to a fixed path.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Dynamic Link</strong></td>
                                        <td><code>[routerLink]="['/user', userId]"</code></td>
                                        <td>Construct paths using variables.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Relative Link</strong></td>
                                        <td><code>routerLink="../details"</code></td>
                                        <td>Navigates relative to the current URL.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-html">&lt;nav&gt;
  &lt;a routerLink="/dashboard"&gt;Dashboard&lt;/a&gt;

  &lt;a [routerLink]="['/profile', user.id]"&gt;My Profile&lt;/a&gt;
&lt;/nav&gt;
</code></pre>
                        <p class="h5">Styling Active Links: <code>routerLinkActive</code></p>
                        <p>To provide visual feedback to the user, the <code>routerLinkActive</code> directive
                            automatically toggles a CSS class on an element when its associated <code>routerLink</code>
                            is currently active.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Input</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>
                                            <code class="text-nowrap">routerLinkActive</code>
                                        </td>
                                        <td>
                                            The CSS class to apply (e.g., <code
                                                class="text-muted">"active-link"</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <code class="text-nowrap">routerLinkActiveOptions</code>
                                        </td>
                                        <td>
                                            <code class="text-muted">{ exact: true }</code> ensures the class is only
                                            applied if the URL matches exactly.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-html">&lt;a routerLink="/home" 
   routerLinkActive="active-nav" 
   [routerLinkActiveOptions]="{ exact: true }"&gt;
   Home
&lt;/a&gt;
</code></pre>
                        <p>Programmatic Navigation: <code>Router</code> Service</p>
                        <p>Sometimes you need to navigate based on logic (e.g., after a successful login or a button
                            click). In these cases, you inject the <code>Router</code> service and use its
                            <code>Maps()</code> or <code>MapsByUrl()</code> methods.
                        </p>
                        <pre><code class="language-javascript">import { Component, inject } from '@angular/core';
import { Router } from '@angular/router';

@Component({ ... })
export class LoginComponent {
  private router = inject(Router);

  onLoginSuccess() {
    // Navigate using an array of commands
    this.router.navigate(['/dashboard']);
    
    // OR navigate using a string path
    // this.router.navigateByUrl('/dashboard');
  }
}
</code></pre>
                        <p>Technical Comparison: <code>Maps</code> vs <code>MapsByUrl</code></p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Method</th>
                                        <th scope="col">Argument</th>
                                        <th scope="col">Use Case</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>Maps()</code></td>
                                        <td><code>any[]</code> (Commands)</td>
                                        <td>Best for dynamic paths with parameters; supports relative navigation.</td>
                                    </tr>
                                    <tr>
                                        <td><code>MapsByUrl()</code></td>
                                        <td><code>string</code></td>
                                        <td>Best for absolute paths; faster as it bypasses command parsing.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>If you are using Standalone Components, you must import <code>RouterModule</code>,
                                    <code>RouterOutlet</code>,
                                    <code>RouterLink</code>, and <code>RouterLinkActive</code> into your component's
                                    <code>imports</code> array to use them in
                                    the template.
                                </p>
                            </div>
                        </div>
                        <p>Warning: When using <code>routerLinkActive</code> on a "Home" route (<code>path: ''</code>),
                            always include
                            <code>[routerLinkActiveOptions]="{ exact: true }"</code>. Otherwise, because the empty path
                            is a prefix
                            of every other path, the "Home" link will appear active regardless of which page the user is
                            actually on.
                        </p>
                    </section>

                    <section class="docs-section" id="item-6-3">
                        <p class="h3">Route Parameters</p>
                        <p>Route parameters allow you to pass dynamic data through the URL, enabling a single component
                            to display different content based on an ID or a slug. For example, instead of creating a
                            unique route for every product in a store, you define one route with a placeholder (e.g.,
                            <code>/product/:id</code>) that adapts to whichever product is requested.
                        </p>
                        <p>Angular supports two main types of parameters: Required Parameters (part of the path) and
                            Query Parameters (after the <code>?</code> in the URL).
                        </p>
                        <p class="h5">1. Required Parameters (Path Params)</p>
                        <p>Required parameters are defined in the route configuration using a colon (:) prefix. The name
                            following the colon is the key you will use to retrieve the value later.
                        </p>
                        <p class="h6">Route Definition:</p>
                        <pre><code class="language-javascript">export const routes: Routes = [
  { path: 'user/:userId', component: UserProfileComponent }
];
</code></pre>
                        <p class="h6">Navigation:</p>
                        <ul>
                            <li>Template: <code>&lt;a [routerLink]="['/user', 42]"&gt;View Profile&lt;/a&gt;</code></li>
                            <li>Resulting URL: <code>localhost:4200/user/42</code></li>
                        </ul>
                        <p class="h5">2. Accessing Parameters</p>
                        <p>There are two modern ways to retrieve these values within your component.</p>
                        <p class="h5">Method A: Component Input Binding (Recommended)</p>
                        <p>Starting in Angular 16, you can bind route parameters directly to component
                            <code>@Input</code> properties. This is the cleanest approach as it keeps your component
                            decoupled from the Router service.
                        </p>
                        <ul>
                            <li>Requirement: You must enable this feature in your app configuration using
                                <code>withComponentInputBinding()</code>.
                            </li>
                        </ul>
                        <pre><code class="language-javascript">// app.config.ts
provideRouter(routes, withComponentInputBinding())

// user-profile.component.ts
export class UserProfileComponent {
  // Variable name MUST match the parameter name in the route path
  @Input() userId!: string; 
}
</code></pre>
                        <p class="h5">Method B: ActivatedRoute Service</p>
                        <p>If you need to react to parameter changes without re-instantiating the component (or if you
                            are on an older version), use the <code>ActivatedRoute</code> service.</p>
                        <pre><code class="language-javascript">import { Component, inject, OnInit, signal } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

export class UserProfileComponent implements OnInit {
  private route = inject(ActivatedRoute);
  userId = signal&lt;string | null&gt;(null);

  ngOnInit() {
    // Snapshot: Use if you know the user won't navigate from user/1 to user/2 directly
    const id = this.route.snapshot.paramMap.get('userId');
    
    // Observable: Use if the ID might change while the component is active
    this.route.paramMap.subscribe(params =&gt; {
      this.userId.set(params.get('userId'));
    });
  }
}
</code></pre>
                        <p class="h5">3. Query Parameters</p>
                        <p>Query parameters are optional and appear at the end of the URL (e.g.,
                            <code>/search?query=angular&page=1</code>). They are ideal for filtering, sorting, or
                            pagination state.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Syntax</th>
                                        <th scope="col">Example URL</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Defining</th>
                                        <td>None required in <code>Routes</code> array.</td>
                                        <td><code>/search</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Navigating</th>
                                        <td><code>[queryParams]="{ page: 1 }"</code></td>
                                        <td><code>/search?page=1</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Retrieving</th>
                                        <td><code>route.snapshot.queryParamMap.get('page')</code></td>
                                        <td><code>1</code></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h6">Navigation Example:</p>
                        <pre><code class="language-html">&lt;a [routerLink]="['/search']" [queryParams]="{ sort: 'price', order: 'asc' }"&gt;
  Sort by Price
&lt;/a&gt;
</code></pre>
                        <p class="h5">Comparison: Path vs. Query Parameters</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Aspect</th>
                                        <th scope="col">Path Parameters ( <code>:id</code> )</th>
                                        <th scope="col">Query Parameters ( <code>?q=</code> )</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Requirement</th>
                                        <td>Mandatory for the route to match.</td>
                                        <td>Optional; route matches without them.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">SEO</th>
                                        <td>Better for search engines (crawlers).</td>
                                        <td>Generally ignored by crawlers for indexing.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Use Case</th>
                                        <td>Identifying a specific resource (User, ID).</td>
                                        <td>Filtering, sorting, and UI state.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Structure</th>
                                        <td>Part of the URL hierarchy.</td>
                                        <td>Appended at the end.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p> When navigating programmatically with the <code>Router</code> service, use the
                                    <code>queryParams</code> property in the navigation extras:
                                    <code>this.router.navigate(['/search'], { queryParams: { q: 'tech' } });</code>.
                                </p>
                            </div>
                        </div>
                        <p>Warning: Always remember that route parameters are strings. If you are passing a numeric ID
                            (like <code>42</code>), you must convert it to a number (e.g., <code>Number(userId)</code>)
                            before performing mathematical operations or strict comparisons (<code>===</code>).
                        </p>
                    </section>

                    <section class="docs-section" id="item-6-4">
                        <p class="h3">Child Routes</p>
                        <p>In complex applications, a page is often composed of a main view and several nested
                            sub-views. For example, a "User Settings" page might have a sidebar with links for
                            "Profile," "Security," and "Notifications." When you click these links, you want the sidebar
                            to stay in place while only the content area changes.</p>
                        <p>Angular handles this through Child Routes (also known as Nested Routing). Child routes allow
                            you to define a hierarchy of components where a child component is rendered inside a
                            specific <code>&lt;router-outlet&gt;</code> located within a parent component's template.
                        </p>
                        <p class="h5">Defining Child Routes</p>
                        <p>Child routes are defined using the <code>children</code> property within a route object. The
                            <code>children</code> property takes an array of routes, just like the top-level
                            configuration.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Property</th>
                                        <th scope="col">Behavior</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row" class="fw-bold">Path</th>
                                        <td>
                                            The child path is appended to the parent path (e.g.,
                                            <code class="bg-light px-1 rounded">settings</code> +
                                            <code class="bg-light px-1 rounded">profile</code> =
                                            <code class="bg-light px-1 rounded">settings/profile</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row" class="fw-bold">Outlet</th>
                                        <td>
                                            The child component renders in the
                                            <code class="bg-light px-1 rounded">&lt;router-outlet&gt;</code>
                                            of the <strong>parent</strong> component, not the root.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">// app.routes.ts
export const routes: Routes = [
  {
    path: 'settings',
    component: SettingsComponent, // This parent MUST have a <router-outlet>
    children: [
      { path: '', redirectTo: 'profile', pathMatch: 'full' }, // Default child
      { path: 'profile', component: ProfileComponent },
      { path: 'security', component: SecurityComponent }
    ]
  }
];
</code></pre>
                        <p class="h5">The Parent Template</p>
                        <p>For child routes to work, the parent component (<code>SettingsComponent</code> in the example
                            above) must contain its own <code>&lt;router-outlet&gt;</code>. This tells the router
                            exactly where to place the child components.
                        </p>
                        <pre><code class="language-html">&lt;div class="settings-layout"&gt;
  &lt;aside class="sidebar"&gt;
    &lt;a routerLink="profile"&gt;Edit Profile&lt;/a&gt;
    &lt;a routerLink="security"&gt;Security Settings&lt;/a&gt;
  &lt;/aside&gt;

  &lt;section class="content-area"&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  &lt;/section&gt;
&lt;/div&gt;
</code></pre>
                        <p class="h5">Navigation to Child Routes</p>
                        <p>When navigating to child routes, you can use absolute or relative paths.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Method</th>
                                        <th scope="col">Link Syntax</th>
                                        <th scope="col">Final URL</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Absolute</th>
                                        <td><code>routerLink="/settings/profile"</code></td>
                                        <td><code>domain.com/settings/profile</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Relative</th>
                                        <td><code>routerLink="profile"</code></td>
                                        <td>Appends to current URL</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Parent</th>
                                        <td><code>routerLink="../"</code></td>
                                        <td>Navigates back up one level</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Accessing Parent Data</p>
                        <p>By default, child routes cannot see the route parameters of their parents. For example, if a
                            child route is at <code>/user/:id/details</code>, the child component's
                            <code>ActivatedRoute</code> will show an empty <code>paramMap</code>.
                        </p>
                        <p>To fix this, you have two options:</p>
                        <ol>
                            <li>Configuration: Set <code>paramsInheritanceStrategy: 'always'</code> in the router
                                configuration.</li>
                            <li>Service: Inject <code>ActivatedRoute</code> and access
                                <code>this.route.parent?.snapshot.paramMap</code>.
                            </li>
                        </ol>
                        <pre><code class="language-javascript">// Accessing parent ID from a child component
const userId = inject(ActivatedRoute).parent?.snapshot.paramMap.get('id');
</code></pre>
                        <p class="h5">Comparison: Components vs. Child Routes</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Standard Components</th>
                                        <th scope="col">Child Routes</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">URL Change</th>
                                        <td>No URL change when swapping.</td>
                                        <td>
                                            URL updates (e.g.,
                                            <code class="bg-light px-1 rounded">/settings/security</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row">State</th>
                                        <td>Lost if parent is destroyed.</td>
                                        <td>Preserved in the URL; bookmarkable.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Use Case</th>
                                        <td>Reusable UI widgets (buttons, cards).</td>
                                        <td>Distinct functional views within a feature.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p> If you use an empty path <code>path: ''</code> for a child route, it will act as the
                                    default view for the parent. This is cleaner than a <code>redirectTo</code> if you
                                    want the parent URL to stay exactly as it is (e.g., <code>/settings</code>
                                    displaying the Profile view immediately).</p>
                            </div>
                        </div>
                        <p>Warning: Avoid nesting routes too deeply (more than 3 levels). Deeply nested routes can make
                            your application difficult to reason about, lead to complex CSS layouts, and make URL
                            management a nightmare for users.
                        </p>
                    </section>

                    <section class="docs-section" id="item-6-5">
                        <p class="h3">Lazy Loading Components</p>
                        <p>Lazy Loading is a design pattern that delays the initialization of a resource until the
                            moment it is actually needed. In Angular, this means the browser doesn't download the code
                            for a specific route until the user navigates to it. This is one of the most effective ways
                            to reduce the Initial Bundle Size, leading to faster load times and a better user
                            experience, especially on mobile devices or slow networks.
                        </p>
                        <p>In modern Angular (v15+), we primarily use Standalone Component Lazy Loading, which is
                            significantly simpler than the older, module-based approach.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Eager Loading (Default)</th>
                                        <th scope="col">Lazy Loading</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Download Time</th>
                                        <td>At application startup.</td>
                                        <td>Only when the route is visited.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Initial Bundle Size</th>
                                        <td>Larger (includes all code).</td>
                                        <td>Smaller (split into chunks).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Navigation Speed</th>
                                        <td>Instant (code is already there).</td>
                                        <td>Slight delay on first visit (downloading).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Best For</th>
                                        <td>Essential views (Home, Login).</td>
                                        <td>Feature modules, Admin panels, Profiles.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Implementing <code>loadComponent</code></p>
                        <p>To lazy load a standalone component, replace the <code>component</code> property in your
                            route definition with <code>loadComponent</code>. This property takes a function that
                            returns a Promise containing the component.
                        </p>
                        <pre><code class="language-javascript">// app.routes.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: 'home',
    component: HomeComponent // Eagerly loaded
  },
  {
    path: 'dashboard',
    // Lazy loaded: only downloaded when user hits /dashboard
    loadComponent: () =&gt; import('./features/dashboard/dashboard.component')
      .then(m =&gt; m.DashboardComponent)
  },
  {
    path: 'settings',
    // Modern shorthand (if the component is the default export)
    loadComponent: () =&gt; import('./features/settings/settings.component')
  }
];
</code></pre>
                        <p class="h5">Lazy Loading a Group of Routes</p>
                        <p>If you have a large feature with multiple sub-routes (like an Admin section), you can lazy
                            load the entire set of child routes at once using <code>loadChildren</code>.
                        </p>
                        <pre><code class="language-javascript">// admin.routes.ts
export const ADMIN_ROUTES: Routes = [
  { path: '', component: AdminShellComponent },
  { path: 'users', component: AdminUsersComponent },
];

// app.routes.ts
{
  path: 'admin',
  loadChildren: () =&gt; import('./admin/admin.routes').then(m =&gt; m.ADMIN_ROUTES)
}
</code></pre>
                        <p class="h5">How it Works: Code Splitting</p>
                        <p>When you use the <code>import()</code> syntax, the Angular compiler (Webpack or Esbuild)
                            recognizes this as a "split point." During the build process, it creates a separate
                            JavaScript file (a chunk) for that component.
                        </p>
                        <ul>
                            <li>Initial Bundle: Contains the framework, core services, and eager components.</li>
                            <li>Lazy Chunks: Named files like <code>chunk-XYZ123.js</code> that sit on the server until
                                requested.</li>
                        </ul>
                        <p class="h5">Preloading Strategies</p>
                        <p>Lazy loading is great for performance, but the slight delay when a user clicks a link can
                            feel "laggy." To solve this, Angular allows Preloading. This downloads the lazy chunks in
                            the background after the initial app has loaded, so they are ready before the user even
                            clicks.
                        </p>
                        <p>You enable this in your <code>app.config.ts</code>:</p>
                        <pre><code class="language-javascript">import { provideRouter, withPreloading, PreloadAllModules } from '@angular/router';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes, withPreloading(PreloadAllModules))
  ]
};
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>For the <code>import()</code> syntax to work correctly, the path must be a string
                                    literal. You cannot use a variable for the path because the compiler needs to know
                                    which file to split at build time.</p>
                            </div>
                        </div>
                        <p>Warning: Don't lazy load every single component. There is a small overhead for every separate
                            file the browser has to request. As a rule of thumb, lazy load at the Route level, not the
                            individual widget/UI element level.
                        </p>
                    </section>

                    <section class="docs-section" id="item-6-6">
                        <p class="h3">Route Guards (CanActivate, CanDeactivate)</p>
                        <p>Route Guards are interfaces or functions that act as "checkpoints" in the navigation process.
                            They allow you to grant or deny access to certain parts of your application based on logic,
                            such as whether a user is logged in, has the correct permissions, or has unsaved changes in
                            a form.</p>
                        <p>In modern Angular, guards are defined as functional guards, which are simpler to write and
                            test than the older class-based approach.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Guard Type</th>
                                        <th scope="col">Purpose</th>
                                        <th scope="col">Common Use Case</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>canActivate</code></td>
                                        <td>Decides if a route can be <strong>entered</strong>.</td>
                                        <td>Authentication and Role-based access (RBAC).</td>
                                    </tr>
                                    <tr>
                                        <td><code>canDeactivate</code></td>
                                        <td>Decides if a route can be <strong>exited</strong>.</td>
                                        <td>Warning users about unsaved changes in a form.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">1. The canActivate Guard</p>
                        <p>A <code>canActivate</code> guard returns <code>true</code> to allow navigation,
                            <code>false</code> to block it, or a <code>UrlTree</code> to redirect the user elsewhere
                            (e.g., to the login page).
                        </p>
                        <pre><code class="language-javascript">import { inject } from '@angular/core';
import { Router, CanActivateFn } from '@angular/router';
import { AuthService } from './auth.service';

export const authGuard: CanActivateFn = (route, state) =&gt; {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn()) {
    return true; // Allow access
  } else {
    // Redirect to login and block the original request
    return router.parseUrl('/login'); 
  }
};
</code></pre>
                        <p class="h5">Applying the guard in <code>app.routes.ts:</code></p>
                        <pre><code class="language-javascript">{ path: 'admin', component: AdminComponent, canActivate: [authGuard] }
</code></pre>
                        <p class="h5">2. The <code>canDeactivate</code> Guard</p>
                        <p>This guard is unique because it has access to the component instance currently being
                            displayed. This allows you to check the internal state of the component (like a dirty form)
                            before the user leaves. </p>
                        <pre><code class="language-javascript">import { CanDeactivateFn } from '@angular/router';

export interface CanComponentDeactivate {
  hasUnsavedChanges: () =&gt; boolean;
}

export const pendingChangesGuard: CanDeactivateFn&lt;CanComponentDeactivate&gt; = (component) =&gt; {
  if (component.hasUnsavedChanges()) {
    return confirm('You have unsaved changes. Do you really want to leave?');
  }
  return true;
};
</code></pre>
                        <p class="h5">Comparison: Guard Return Types</p>
                        <p>Guards are flexible and can handle asynchronous logic (like checking a session with a
                            server).</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Return Type</th>
                                        <th scope="col">Behavior</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>boolean</code></td>
                                        <td>Synchronous allow ( <code>true</code> ) or deny ( <code>false</code> ).</td>
                                    </tr>
                                    <tr>
                                        <td><code>UrlTree</code></td>
                                        <td>Immediate redirection to a different route.</td>
                                    </tr>
                                    <tr>
                                        <td><code>Observable&lt;boolean | UrlTree&gt;</code></td>
                                        <td>Asynchronous check (waits for the first value).</td>
                                    </tr>
                                    <tr>
                                        <td><code>Promise&lt;boolean | UrlTree&gt;</code></td>
                                        <td>Asynchronous check (waits for resolution).</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Other Useful Guards</p>
                        <ul>
                            <li><code>canMatch:</code> Determines if a route can even be considered for matching. Useful
                                for loading different components for the same URL based on user roles.
                            </li>
                            <li>
                                <code>canActivateChild:</code> Similar to <code>canActivate</code>, but applies to all
                                child routes of a parent automatically.
                            </li>
                            <li><code>resolve</code>: Not strictly a guard, but runs during the guard phase to fetch
                                data before the component is even instantiated.
                            </li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Because guards are just functions, you can compose them. For example,
                                    <code>canActivate: [authGuard, adminGuard]</code> requires the user to be both
                                    logged in and an administrator.
                                </p>
                            </div>
                        </div>
                        <p>Warning: Route Guards are for User Experience, not Security. A savvy user can always bypass
                            client-side guards by modifying the JavaScript. Always ensure your Backend API also
                            validates permissions for every request to ensure data security.
                        </p>
                    </section>
                </article>

                <article class="docs-article" id="section-7">
                    <header class="docs-header">
                        <p class="h2 docs-heading">Section 7: Forms</p>
                    </header>
                    <hr>
                    <section class="docs-section" id="item-7-1">
                        <p class="h3">Reactive Forms (The Standard)</p>
                        <p>In Angular, Reactive Forms provide a model-driven approach to handling form inputs whose
                            values change over time. Unlike Template-Driven forms, which rely on directives in the HTML,
                            Reactive Forms are defined explicitly in the TypeScript class. This gives you synchronous
                            access to the data model, making it the industry standard for complex forms, dynamic
                            validation, and testing.
                        </p>
                        <p class="h5">Core Building Blocks</p>
                        <p>To build a reactive form, you use three fundamental classes from <code>@angular/forms</code>.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Class</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>FormControl</strong></td>
                                        <td>Manages the value and validation status of an individual input field.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>FormGroup</strong></td>
                                        <td>
                                            Groups multiple <code>FormControl</code> (or other groups) into a
                                            single logical unit.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><strong>FormArray</strong></td>
                                        <td>
                                            Manages an ordered list of form controls, useful for
                                            dynamic lists.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Implementing a Basic Reactive Form</p>
                        <p>To use Reactive Forms, you must import <code>ReactiveFormsModule</code> into your component's
                            <code>imports</code> array.
                        </p>
                        <pre><code class="language-javascript">import { Component, OnInit } from '@angular/core';
import { FormGroup, FormControl, Validators, ReactiveFormsModule } from '@angular/forms';

@Component({
  selector: 'app-user-form',
  standalone: true,
  imports: [ReactiveFormsModule],
  template: `
    &lt;form [formGroup]="userForm" (ngSubmit)="onSubmit()"&gt;
      &lt;label&gt;Name: &lt;input formControlName="name"&gt;&lt;/label&gt;
      &lt;label&gt;Email: &lt;input formControlName="email"&gt;&lt;/label&gt;
      &lt;button type="submit" [disabled]="userForm.invalid"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  `
})
export class UserFormComponent {
  // Define the form structure in TypeScript
  userForm = new FormGroup({
    name: new FormControl('', Validators.required),
    email: new FormControl('', [Validators.required, Validators.email])
  });

  onSubmit() {
    console.log(this.userForm.value);
  }
}
</code></pre>
                        <p class="h5">Using FormBuilder</p>
                        <p>As forms grow, manually instantiating <code>new FormGroup</code> and
                            <code>new FormControl</code> becomes verbose. The <code>FormBuilder</code> service provides
                            a syntactic sugar that makes form definition more concise.
                        </p>
                        <pre><code class="language-javascript">import { inject } from '@angular/core';
import { FormBuilder, Validators } from '@angular/forms';

export class ProfileComponent {
  private fb = inject(FormBuilder);

  profileForm = this.fb.group({
    firstName: ['', Validators.required],
    lastName: [''],
    address: this.fb.group({ // Nested Group
      street: [''],
      city: ['']
    })
  });
}
</code></pre>
                        <p class="h5">Key Advantages of Reactive Forms</p>
                        <ul>
                            <li>Predictability: The data flow is synchronous; the model is the source of truth.
                            </li>
                            <li>Powerful Validation: Easily handle complex cross-field validation.
                            </li>
                            <li>Observable-Based: You can listen to changes in real-time using
                                <code>valueChanges</code>.
                            </li>
                            <li>Testability: You can test form logic in isolated unit tests without needing a DOM.
                            </li>
                        </ul>
                        <p class="h5">Reactive Forms vs. Template-Driven</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Reactive Forms</th>
                                        <th scope="col">Template-Driven</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Setup</th>
                                        <td>More code (TS-heavy).</td>
                                        <td>Less code (HTML-heavy).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Data Flow</th>
                                        <td>Synchronous.</td>
                                        <td>Asynchronous.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Validation</th>
                                        <td>Functions in TS.</td>
                                        <td>Directives in HTML.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Scalability</th>
                                        <td>High (complex logic).</td>
                                        <td>Lower (simple forms).</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Reactive Forms are heavily based on RxJS. Every <code>FormControl</code>,
                                    <code>FormGroup</code>, and <code>FormArray</code> has a <code>valueChanges</code>
                                    observable that emits the new value every time it changes. This is perfect for
                                    features like "auto-save" or "real-time search."
                                </p>
                            </div>
                        </div>
                        <p>Warning: Always remember to link the HTML to the TS model using <code>[formGroup]</code> on
                            the form element and <code>formControlName</code> on the inputs. If the names don't match
                            exactly, Angular will throw a runtime error.
                        </p>
                    </section>

                    <section class="docs-section" id="item-7-2">
                        <p class="h3">Form Controls & Groups</p>
                        <p>To manage complex data structures, Reactive Forms organize inputs into a logical hierarchy.
                            Understanding the relationship between FormControl and FormGroup is essential for tracking
                            validity and extracting values from nested data models.
                        </p>
                        <p class="h5">1. FormControl: The Individual Unit</p>
                        <p>A <code>FormControl</code> is the smallest building block. It tracks the value, validation
                            status (Valid, Invalid, Pending), and user interaction state (Pristine/Dirty,
                            Touched/Untouched) for a single input element.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col" style="width: 30%;">State Property</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>value</code></td>
                                        <td>The current value of the control.</td>
                                    </tr>
                                    <tr>
                                        <td><code>status</code></td>
                                        <td>The validation status (e.g., <span
                                                class="badge bg-light text-dark border">VALID</span>, <span
                                                class="badge bg-light text-dark border">INVALID</span>).</td>
                                    </tr>
                                    <tr>
                                        <td><code>pristine</code></td>
                                        <td><code>true</code> if the user has <strong>not</strong> changed the value in
                                            the UI.</td>
                                    </tr>
                                    <tr>
                                        <td><code>touched</code></td>
                                        <td><code>true</code> if the user has focused and blurred the input.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">// Initializing a standalone control
const username = new FormControl('Guest', Validators.required);

console.log(username.value); // 'Guest'
username.setValue('Admin');   // Updates value and triggers validation
</code></pre>
                        <p class="h5">2. FormGroup: The Container</p>
                        <p>A <code>FormGroup</code> aggregates multiple controls into a single object. The group’s
                            status is determined by its children: if any single control is invalid, the entire group is
                            marked as invalid.
                        </p>
                        <pre><code class="language-javascript">userForm = new FormGroup({
  firstName: new FormControl(''),
  lastName: new FormControl('')
});
</code></pre>
                        <p>In your HTML, you bind the group using <code>[formGroup]</code> and the individual controls
                            using <code>formControlName</code>.
                        </p>
                        <pre><code class="language-html">&lt;div [formGroup]="userForm"&gt;
  &lt;input formControlName="firstName"&gt;
  &lt;input formControlName="lastName"&gt;
&lt;/div&gt;
</code></pre>
                        <p class="h5">3. Nested FormGroups</p>
                        <p>For complex data models, you can nest FormGroup instances inside other groups. This is ideal
                            for sections like "Address" or "Payment Info" within a larger profile form.</p>
                        <div class="container mt-4">
                            <div class="table-responsive">
                                <table class="table table-striped table-hover align-middle">
                                    <thead class="table-dark">
                                        <tr>
                                            <th scope="col">Component</th>
                                            <th scope="col">Code Implementation</th>
                                            <th scope="col">Template Binding</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <th scope="row" class="fw-bold">Parent Group</th>
                                            <td><code>profileForm = fb.group({...})</code></td>
                                            <td><code>[formGroup]="profileForm"</code></td>
                                        </tr>
                                        <tr>
                                            <th scope="row" class="fw-bold">Child Group</th>
                                            <td><code>address: fb.group({...})</code></td>
                                            <td><code>formGroupName="address"</code></td>
                                        </tr>
                                        <tr>
                                            <th scope="row" class="fw-bold">Input</th>
                                            <td><code>street: ['']</code></td>
                                            <td><code>formControlName="street"</code></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <p class="h6">Example of Nested Logic:</p>
                        <pre><code class="language-javascript">this.profileForm = new FormGroup({
  id: new FormControl(1),
  contact: new FormGroup({
    email: new FormControl('', Validators.email),
    phone: new FormControl('')
  })
});
</code></pre>
                        <p class="h5">Updating Form Values</p>
                        <p>Angular provides two distinct methods for programmatically updating form data. Choosing the
                            right one is critical for avoiding errors.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Method</th>
                                        <th scope="col">Behavior</th>
                                        <th scope="col">Use Case</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>setValue()</code></td>
                                        <td>
                                            Must match the <strong>exact structure</strong> of the group.
                                            Throws error if a key is missing.
                                        </td>
                                        <td>
                                            When you are replacing the entire form state (e.g., loading an
                                            object from an API).
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>patchValue()</code></td>
                                        <td>
                                            Updates only the provided keys; ignores missing ones.
                                        </td>
                                        <td>
                                            When you only want to update a subset of fields.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">// ❌ Error: Missing 'lastName'
this.userForm.setValue({ firstName: 'Jane' }); 

// ✅ Success: Only updates 'firstName'
this.userForm.patchValue({ firstName: 'Jane' });
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>To clear a form and reset all its statuses (like <code>touched</code> and
                                    <code>dirty</code>), use the <code>reset()</code>
                                    method. You can optionally pass an object to
                                    <code>reset({ firstName: 'Default' })</code> to
                                    provide initial values simultaneously.
                                </p>
                            </div>
                        </div>
                        <p>Warning: Never attempt to change a <code>FormControl</code> value directly via the DOM or by
                            modifying a
                            variable. Always use <code>setValue()</code> or <code>patchValue()</code> to ensure the
                            internal validation logic and
                            the UI remain in sync.
                        </p>
                    </section>

                    <section class="docs-section" id="item-7-3">
                        <p class="h3">Form Arrays</p>
                        <p>While FormGroup is used for objects with a fixed set of keys, FormArray is designed to manage
                            a dynamic list of form controls. It is the go-to solution when you need to allow users to
                            add or remove fields on the fly—such as adding multiple phone numbers, inviting several team
                            members, or listing line items in an invoice.
                        </p>
                        <p class="h5">Core Characteristics of FormArray</p>
                        <p>A <code>FormArray</code> behaves similarly to a standard JavaScript array, but it contains
                            <code>FormControl</code>, <code>FormGroup</code>, or even other <code>FormArray</code>
                            instances.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Dynamic Length</th>
                                        <td>You can push, insert, or remove controls at runtime.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Index-Based</th>
                                        <td>Controls are accessed by their numerical index (0, 1, 2...).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Aggregated Status</th>
                                        <td>
                                            The array is <span>INVALID</span> if any control within it fails validation.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Implementing a Dynamic List</p>
                        <p>To create a <code>FormArray</code>, you typically define it within a <code>FormGroup</code>.
                            In the template, you iterate through the array's controls using a loop.</p>
                        <pre><code class="language-javascript">import { Component, inject } from '@angular/core';
import { FormBuilder, FormArray, ReactiveFormsModule, Validators } from '@angular/forms';

@Component({
  selector: 'app-hobby-form',
  standalone: true,
  imports: [ReactiveFormsModule],
  template: `
    &lt;form [formGroup]="userForm"&gt;
      &lt;div formArrayName="hobbies"&gt;
        @for (hobby of hobbies.controls; track $index) {
          &lt;div&gt;
            &lt;input [formControlName]="$index" placeholder="Hobby name"&gt;
            &lt;button (click)="removeHobby($index)"&gt;Remove&lt;/button&gt;
          &lt;/div&gt;
        }
      &lt;/div&gt;
      &lt;button (click)="addHobby()"&gt;Add Hobby&lt;/button&gt;
    &lt;/form&gt;
  `
})
export class HobbyFormComponent {
  private fb = inject(FormBuilder);

  userForm = this.fb.group({
    hobbies: this.fb.array([this.fb.control('')]) // Start with one empty field
  });

  // Getter for easy access in the template
  get hobbies() {
    return this.userForm.get('hobbies') as FormArray;
  }

  addHobby() {
    this.hobbies.push(this.fb.control('', Validators.required));
  }

  removeHobby(index: number) {
    this.hobbies.removeAt(index);
  }
}
</code></pre>
                        <p class="h5">FormArray of FormGroups</p>
                        <p>For more complex scenarios, you might need an array where each item is a group of fields
                            (e.g., an array of "Addresses" where each address has a street, city, and zip).</p>
                        <p class="h6">Code Structure:</p>
                        <pre><code class="language-javascript">this.orderForm = this.fb.group({
  items: this.fb.array([
    this.fb.group({
      productName: ['', Validators.required],
      quantity: [1, Validators.min(1)]
    })
  ])
});
</code></pre>
                        <p class="h6">Template Binding:</p>
                        <pre><code class="language-html">&lt;div formArrayName="items"&gt;
  &lt;div *ngFor="let item of items.controls; let i=index" [formGroupName]="i"&gt;
    &lt;input formControlName="productName"&gt;
    &lt;input formControlName="quantity" type="number"&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
                        <p class="h5">Common FormArray Methods</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Method</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>at(index)</code></td>
                                        <td>Returns the control at the specified index.</td>
                                    </tr>
                                    <tr>
                                        <td><code>push(control)</code></td>
                                        <td>Adds a new control to the end of the array.</td>
                                    </tr>
                                    <tr>
                                        <td><code>insert(index, control)</code></td>
                                        <td>Adds a new control at a specific position.</td>
                                    </tr>
                                    <tr>
                                        <td><code>removeAt(index)</code></td>
                                        <td>Removes the control at the specified index.</td>
                                    </tr>
                                    <tr>
                                        <td><code>clear()</code></td>
                                        <td>Removes all controls from the array.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Because the <code>controls</code> property of a <code>FormArray</code> is technically
                                    an array of
                                    <code>AbstractControl</code>, you usually need to use a Getter in your TypeScript
                                    class to cast
                                    it correctly. This ensures your template has access to array-specific properties
                                    without TypeScript errors.
                                </p>
                            </div>
                        </div>
                        <p>Warning: Be careful with the <code>track</code> expression in your <code>@for</code> loops.
                            If you use the control
                            itself as the tracking key, Angular might lose focus on the input when the array structure
                            changes. Using the index (<code>$index</code>) is standard for <code>FormArray</code>, but
                            if you are shuffling items,
                            consider adding a unique ID to each group.
                        </p>
                    </section>

                    <section class="docs-section" id="item-7-4">
                        <p class="h3">Form Validation (Built-in & Custom)</p>
                        <p>Validation is the process of ensuring that user input meets specific criteria before it is
                            processed or sent to a server. In Reactive Forms, validation is handled by functions that
                            take a control as an argument and return a map of errors or null if the input is valid.
                        </p>
                        <p class="h5">1. Built-in Validators</p>
                        <p>Angular provides a suite of common validators ready for use. These are found in the
                            <code>Validators</code> class and are passed as the second argument (or as an array for
                            multiple validators) when initializing a <code>FormControl</code>.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Validator</th>
                                        <th scope="col">Requirement</th>
                                        <th scope="col">Example</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>required</code></td>
                                        <td>Field must not be empty.</td>
                                        <td><code>Validators.required</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>minLength(n)</code></td>
                                        <td>Minimum character count.</td>
                                        <td><code>Validators.minLength(5)</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>maxLength(n)</code></td>
                                        <td>Maximum character count.</td>
                                        <td><code>Validators.maxLength(20)</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>email</code></td>
                                        <td>Must follow email format.</td>
                                        <td><code>Validators.email</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>pattern(reg)</code></td>
                                        <td>Must match a Regular Expression.</td>
                                        <td><code>Validators.pattern('^[0-9]*$')</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>min(n) / max(n)</code></td>
                                        <td>Numeric range limits.</td>
                                        <td><code>Validators.min(18)</code></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h6">Usage Example:</p>
                        <pre><code class="language-javascript">username = new FormControl('', [Validators.required, Validators.minLength(3)]);
</code></pre>
                        <p class="h5">2. Displaying Validation Errors</p>
                        <p>In the template, you can check the status of a control to show conditional error messages. It
                            is a best practice to wait until the user has interacted with the field
                            (<code>touched</code>) before showing errors to avoid a "sea of red" on a fresh form.</p>
                        <pre><code class="language-html">&lt;input formControlName="email"&gt;
@if (userForm.get('email')?.invalid &amp;&amp; userForm.get('email')?.touched) {
  &lt;div class="error"&gt;
    @if (userForm.get('email')?.errors?.['required']) { &lt;span&gt;Email is required.&lt;/span&gt; }
    @if (userForm.get('email')?.errors?.['email']) { &lt;span&gt;Invalid email format.&lt;/span&gt; }
  &lt;/div&gt;
}
</code></pre>
                        <p class="h5">3. Custom Validators</p>
                        <p>When built-in validators aren't enough (e.g., checking if a username is "Admin"), you can
                            write your own. A custom validator is simply a function that returns an error object if the
                            check fails.</p>
                        <pre><code class="language-javascript">import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';

export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null =&gt; {
    const forbidden = nameRe.test(control.value);
    // Returns { key: value } if error, null if valid
    return forbidden ? { forbiddenName: { value: control.value } } : null;
  };
}
</code></pre>
                        <p class="h5">4. Cross-Field Validation</p>
                        <p>Sometimes validation depends on the values of two different fields (e.g., "Password" and
                            "Confirm Password" must match). For this, you apply the validator to the FormGroup rather
                            than an individual control.</p>
                        <pre><code class="language-javascript">const registrationForm = new FormGroup({
  password: new FormControl(''),
  confirmPassword: new FormControl('')
}, { validators: passwordMatchValidator });

function passwordMatchValidator(group: AbstractControl): ValidationErrors | null {
  const pass = group.get('password')?.value;
  const confirm = group.get('confirmPassword')?.value;
  return pass === confirm ? null : { passwordMismatch: true };
}
</code></pre>
                        <p class="h5">5. Async Validators</p>
                        <p>If validation requires an HTTP request (e.g., checking if an email is already taken in the
                            database), you use an Async Validator. These return an <code>Observable</code> or
                            <code>Promise</code>.
                        </p>
                        <ul>
                            <li>Execution: They run only after all synchronous validators pass.</li>
                            <li>Status: While waiting for the response, the control status is set to
                                <code>PENDING</code>.
                            </li>
                        </ul>
                        <pre><code class="language-javascript">email = new FormControl('', {
  validators: [Validators.required],
  asyncValidators: [this.emailLookupService.validateUniqueEmail()],
  updateOn: 'blur' // Optimization: only run on blur, not every keystroke
});
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>The <code>updateOn</code> property can be set to <code> 'change'</code> (default),
                                    <code>'blur'</code>, or <code>'submit'</code>. Changing this to <code>'blur'</code>
                                    for fields with heavy validation or async checks can significantly improve
                                    application performance.
                                </p>
                            </div>
                        </div>
                        <p>Warning: Always provide feedback to the user when a form is <code>PENDING</code>. If an async
                            validator takes 2 seconds and there is no loading indicator, the user might try to submit
                            the form repeatedly, thinking it is broken.
                        </p>
                    </section>

                    <section class="docs-section" id="item-7-5">
                        <p class="h3">Template-Driven Forms (Legacy/Simple)</p>
                        <p>While Reactive Forms are the standard for robust applications, Template-Driven Forms offer a
                            simpler, more declarative approach. They rely heavily on directives within the HTML template
                            to create and manage the form model implicitly. This "legacy" approach is still useful for
                            very simple forms, prototypes, or when migrating older Angular applications.
                        </p>
                        <p class="h5">Core Characteristics</p>
                        <p>Template-Driven forms use Two-Way Data Binding (<code>[(ngModel)]</code>) to keep the
                            component's data properties and the input fields in sync.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Source of Truth</th>
                                        <td>The Template (HTML).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Data Flow</th>
                                        <td>Asynchronous (updates happen through change detection).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Validation</th>
                                        <td>
                                            Applied via HTML attributes (e.g.,
                                            <code class="bg-light border px-1 rounded text-dark">required</code>,
                                            <code class="bg-light border px-1 rounded text-dark">email</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Complexity</th>
                                        <td>Simple to set up, but difficult to scale or unit test.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Basic Implementation</p>
                        <p>To use Template-Driven forms, you must import <code>FormsModule</code> into your component.
                        </p>
                        <pre><code class="language-javascript">import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-login-form',
  standalone: true,
  imports: [FormsModule],
  template: `
    &lt;form #loginForm="ngForm" (ngSubmit)="onSubmit(loginForm)"&gt;
      &lt;label&gt;Email:&lt;/label&gt;
      &lt;input type="email" name="email" ngModel required email #emailModel="ngModel"&gt;
      
      @if (emailModel.invalid &amp;&amp; emailModel.touched) {
        &lt;small&gt;Please enter a valid email.&lt;/small&gt;
      }

      &lt;button type="submit" [disabled]="loginForm.invalid"&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  `
})
export class LoginFormComponent {
  onSubmit(form: any) {
    console.log('Form Values:', form.value);
  }
}
</code></pre>
                        <p class="h5">Key Directives</p>
                        <p>Template-Driven forms rely on a specific set of directives to bridge the gap between HTML and
                            Angular's internal form engine.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col" style="width: 30%;">Directive</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>ngForm</code></td>
                                        <td>Automatically attached to <code>&lt;form&gt;</code>. It tracks the overall
                                            value and validity.</td>
                                    </tr>
                                    <tr>
                                        <td><code>ngModel</code></td>
                                        <td>Binds an individual input to a property and tracks its state.</td>
                                    </tr>
                                    <tr>
                                        <td><code>ngModelGroup</code></td>
                                        <td>Groups related inputs (e.g., address) within the template.</td>
                                    </tr>
                                    <tr>
                                        <td><code>#ref="ngModel"</code></td>
                                        <td>Creates a local variable to access validation errors in the HTML.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Comparison: Template-Driven vs. Reactive</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Aspect</th>
                                        <th scope="col">Template-Driven</th>
                                        <th scope="col">Reactive</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Logic Location</th>
                                        <td>Mostly HTML.</td>
                                        <td>Mostly TypeScript.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Validation</th>
                                        <td>Directives (easy but limited).</td>
                                        <td>Functions (highly flexible).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Unit Testing</th>
                                        <td>Requires rendering the DOM.</td>
                                        <td>Can test logic without the DOM.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Best For</th>
                                        <td>Simple forms, small apps.</td>
                                        <td>Enterprise apps, complex logic.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Why is it "Legacy"?</p>
                        <p>While not deprecated, Template-Driven forms are often avoided in modern professional
                            development for several reasons:</p>
                        <ul>
                            <li>Hidden Complexity: Much of the magic happens behind the scenes, making debugging
                                difficult.</li>
                            <li>Testing Hurdles: Because the model is tied to the template, you cannot test form logic
                                without spinning up a full component test bed.</li>
                            <li>Dynamic Fields: Adding or removing fields dynamically (as with <code>FormArray</code>)
                                is significantly more complex in Template-Driven forms.</li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Even in Template-Driven forms, Angular applies CSS classes to inputs based on their
                                    state (e.g., <code>.ng-invalid</code>, <code>.ng-dirty</code>). You can use these in
                                    your global styles to provide instant visual feedback to the user.</p>
                            </div>
                        </div>
                        <p>Warning: When using <code>ngModel</code> inside a <code>&lt;form&gt;</code> tag, you must
                            define a <code>name</code> attribute on each input. Angular uses this name to register the
                            control with the parent <code>ngForm</code> group. Without it, the input will not be
                            tracked.</p>
                    </section>
                </article>

                <article class="docs-article" id="section-8">
                    <header class="docs-header">
                        <p class="h2 docs-heading">Section 8: HTTP & Client-Server</p>
                    </header>
                    <hr>
                    <section class="docs-section" id="item-8-1">
                        <p class="h3">HttpClient Module</p>
                        <p>The HttpClient is Angular’s built-in mechanism for communicating with backend services over
                            the HTTP protocol. It is built on top of XMLHttpRequest, but offers a modernized,
                            developer-friendly API that leverages RxJS Observables for handling asynchronous data.
                        </p>
                        <p class="h5">Key Features of HttpClient</p>
                        <ul>
                            <li>Observable-based API: Allows for powerful data manipulation (mapping, filtering,
                                retrying) using RxJS.</li>
                            <li>Type Safety: Supports specifying the expected return type from an API.</li>
                            <li>Interceptors: Allows you to intercept and modify requests/responses globally (e.g.,
                                adding Auth headers).</li>
                            <li>Automatic JSON Parsing: Automatically converts JSON responses into TypeScript objects.
                            </li>
                            <li>Testing Utilities: Includes a dedicated testing module
                                (<code>HttpClientTestingModule</code>) for mocking backend responses.</li>
                        </ul>
                        <p class="h5">1. Configuration (Setup)</p>
                        <p>In modern Angular applications, you enable the <code>HttpClient</code> within your
                            application configuration (<code>app.config.ts</code>) using the
                            <code>provideHttpClient()</code> function.
                        </p>
                        <pre><code class="language-javascript">// app.config.ts
import { provideHttpClient } from '@angular/common/http';

export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient()
  ]
};
</code></pre>
                        <p class="h5">2. Basic Usage in a Service</p>
                        <p>Data fetching logic should always reside in a Service, not the component. The service injects
                            the <code>HttpClient</code> and returns an Observable to the consumer.</p>
                        <pre><code class="language-javascript">import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

export interface Post {
  id: number;
  title: string;
  body: string;
}

@Injectable({ providedIn: 'root' })
export class PostService {
  private http = inject(HttpClient);
  private apiUrl = 'https://jsonplaceholder.typicode.com/posts';

  // Fetch all posts - returns an Observable&lt;Post[]&gt;
  getPosts(): Observable&lt;Post[]&gt; {
    return this.http.get&lt;Post[]&gt;(this.apiUrl);
  }
}
</code></pre>
                        <p class="h5">3. Common HTTP Methods</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Method</th>
                                        <th scope="col">Purpose</th>
                                        <th scope="col">Example Syntax</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">GET</th>
                                        <td>Retrieve data from the server.</td>
                                        <td><code>this.http.get&lt;T&gt;(url)</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">POST</th>
                                        <td>Send data to create a new resource.</td>
                                        <td><code>this.http.post&lt;T&gt;(url, body)</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">PUT</th>
                                        <td>Replace an existing resource entirely.</td>
                                        <td><code>this.http.put&lt;T&gt;(url, body)</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">PATCH</th>
                                        <td>Update specific parts of a resource.</td>
                                        <td><code>this.http.patch&lt;T&gt;(url, body)</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">DELETE</th>
                                        <td>Remove a resource from the server.</td>
                                        <td><code>this.http.delete&lt;T&gt;(url)</code></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">4. Consuming HTTP Data in a Component</p>
                        <p>To get data into your UI, you must subscribe to the Observable returned by the service.</p>
                        <pre><code class="language-javascript">@Component({ ... })
export class PostListComponent implements OnInit {
  private postService = inject(PostService);
  posts: Post[] = [];

  ngOnInit() {
    this.postService.getPosts().subscribe({
      next: (data) =&gt; this.posts = data,
      error: (err) =&gt; console.error('Failed to fetch posts', err)
    });
  }
}
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Whenever you <code>.subscribe()</code> manually in a component, you are responsible
                                    for unsubscribing when the component is destroyed to prevent memory leaks.
                                    Alternatively, use the AsyncPipe in the template, which handles subscription and
                                    unsubscription automatically.</p>
                            </div>
                        </div>
                        <p class="h6">Request Options</p>
                        <p>The <code>HttpClient</code> methods allow for an optional <code>options</code> object where
                            you can specify headers, query parameters, and how to observe the response.</p>
                        <ul>
                            <li>Headers: Use <code>HttpHeaders</code> to send authentication tokens.</li>
                            <li>Params: Use <code>HttpParams</code> to add query strings like
                                <code>?page=1&limit=10</code>.
                            </li>
                            <li>Observe: By default, it returns the body. Use <code>{ observe: 'response' }</code> to
                                get the full <code>HttpResponse</code> object (including status codes and headers).</li>
                        </ul>
                        <p>Warning: Never hardcode your API Base URL directly into your services. Use Environment Files
                            (e.g., <code>environment.ts</code> and <code>environment.prod.ts</code>) to store these
                            URLs. This ensures that your app automatically points to the correct server (Local, Staging,
                            or Production) during the build process.
                        </p>
                    </section>

                    <section class="docs-section" id="item-8-2">
                        <p class="h3">Making Requests (GET, POST, etc.)</p>
                        <p>While the HttpClient service provides a consistent interface, each HTTP method is designed
                            for a specific type of interaction with the backend. Angular’s implementation is type-safe,
                            meaning you can define exactly what shape of data you expect to receive from your API.</p>
                        <p class="h5">1. GET: Retrieving Data</p>
                        <p>The <code>get()</code> method is used to fetch resources. It is idempotent, meaning multiple
                            identical requests should have the same effect as a single request (fetching the same data).
                        </p>
                        <pre><code class="language-javascript">// Define an interface for type safety
export interface User {
  id: number;
  name: string;
}

getUsers(): Observable&lt;User[]&gt; {
  // Specifying &lt;User[]&gt; ensures 'next' emits an array of Users
  return this.http.get&lt;User[]&gt;(`${this.apiUrl}/users`);
}
</code></pre>
                        <p class="h5">2. POST: Creating Data</p>
                        <p>The <code>post()</code> method sends a data payload (the "body") to the server to create a
                            new resource.</p>
                        <ul>
                            <li>Body: Usually a JavaScript object which Angular automatically stringifies to JSON.</li>
                            <li>Response: Usually returns the newly created object, often including an assigned ID.</li>
                        </ul>
                        <pre><code class="language-javascript">createUser(newUser: Partial&lt;User&gt;): Observable&lt;User&gt; {
  return this.http.post&lt;User&gt;(`${this.apiUrl}/users`, newUser);
}
</code></pre>
                        <p class="h5">3. PUT vs. PATCH: Updating Data</p>
                        <p>Both methods are used to update existing resources, but they represent different intentions.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Method</th>
                                        <th scope="col">Intention</th>
                                        <th scope="col">Backend Behavior</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">PUT</th>
                                        <td>Replace</td>
                                        <td>Overwrites the entire resource with the provided body.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">PATCH</th>
                                        <td>Partial Update</td>
                                        <td>Updates only the specific fields provided in the body.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <pre><code class="language-javascript">// PUT: Replace the whole user object
updateUser(user: User): Observable&lt;User&gt; {
  return this.http.put&lt;User&gt;(`${this.apiUrl}/users/${user.id}`, user);
}

// PATCH: Just update the email
updateEmail(id: number, email: string): Observable&lt;User&gt; {
  return this.http.patch&lt;User&gt;(`${this.apiUrl}/users/${id}`, { email });
}
</code></pre>
                        <p class="h5">4. DELETE: Removing Data</p>
                        <p>The <code>delete()</code> method removes a resource. It typically does not require a body,
                            only the identifier in the URL.</p>
                        <pre><code class="language-javascript">deleteUser(id: number): Observable&lt;void&gt; {
  return this.http.delete&lt;void&gt;(`${this.apiUrl}/users/${id}`);
}
</code></pre>
                        <p class="h5">5. Configuring Request Options</p>
                        <p>Every HTTP method accepts an optional <code>Options</code> object as its last argument. This
                            is used to add Headers, Query Parameters, or change the Response Type.</p>
                        <p class="h6">Adding Headers and Params</p>
                        <pre><code class="language-javascript">import { HttpHeaders, HttpParams } from '@angular/common/http';

getFilteredUsers(role: string) {
  const myHeaders = new HttpHeaders().set('Authorization', 'Bearer token123');
  const myParams = new HttpParams().set('role', role).set('limit', '10');

  return this.http.get&lt;User[]&gt;(this.apiUrl, {
    headers: myHeaders,
    params: myParams
  });
}
</code></pre>
                        <p class="h6">Technical Summary: Response Handling</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Property</th>
                                        <th scope="col">Default Value</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>observe</code></td>
                                        <td><code>'body'</code></td>
                                        <td>
                                            Can be set to <code>'response'</code> to get the full
                                            <code>HttpResponse</code> object (status, headers, etc.).
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>responseType</code></td>
                                        <td><code>'json'</code></td>
                                        <td>
                                            Can be set to <code>'text'</code>, <code>'blob'</code> (for files),
                                            or <code>'arraybuffer'</code>.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>reportProgress</code></td>
                                        <td><code>false</code></td>
                                        <td>
                                            Set to <code>true</code> for tracking file upload/download progress.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>The <code>HttpClient</code> methods are "cold" observables. This means the HTTP
                                    request is not sent until you or the template (via <code>AsyncPipe</code>) actually
                                    calls <code>.subscribe()</code>. If you call the service method but don't subscribe,
                                    no network traffic will occur.</p>
                            </div>
                        </div>
                        <p>Warning: Most modern APIs expect JSON. If you are sending a raw string or an unusual data
                            format, you must manually set the <code>Content-Type</code> header to avoid "415 Unsupported
                            Media Type" errors.
                        </p>
                    </section>

                    <section class="docs-section" id="item-8-3">
                        <p class="h3">Http Interceptors (Handling Headers/Errors)</p>
                        <p>HTTP Interceptors act as a "middleware" layer for your outgoing requests and incoming
                            responses. Instead of manually adding an authentication token or handling errors in every
                            single service, you can write an Interceptor once to handle these tasks globally.</p>
                        <p>In modern Angular, we use Functional Interceptors, which are lightweight and easier to
                            configure than the older class-based system.</p>
                        <p class="h5">1. How Interceptors Work</p>
                        <p>Interceptors sit between your application code and the backend. They can:</p>
                        <ul>
                            <li>Modify Requests: Add <code>Authorization</code> headers, change URLs, or set content
                                types.</li>
                            <li>Modify Responses: Transform data formats or log execution times.</li>
                            <li>Handle Errors: Catch 401 (Unauthorized) or 500 (Server Error) responses globally.</li>
                            <li>Show Loaders: Trigger a global loading spinner when a request starts and hide it when it
                                finishes.</li>
                        </ul>
                        <p class="h5">2. Creating a Functional Interceptor</p>
                        <p>A functional interceptor is a simple function that receives the <code>HttpRequest</code> and
                            a <code>next</code> handler. Because requests are immutable, you must <code>clone()</code> a
                            request if you wish to change it.
                        </p>
                        <p class="h6">Adding an Auth Header</p>
                        <pre><code class="language-javascript">import { HttpInterceptorFn } from '@angular/common/http';

export const authInterceptor: HttpInterceptorFn = (req, next) =&gt; {
  const authToken = 'MY_CONFIDENTIAL_TOKEN'; // Usually retrieved from a service

  // Clone the request to add the new header
  const authReq = req.clone({
    setHeaders: {
      Authorization: `Bearer ${authToken}`
    }
  });

  // Pass the cloned request to the next handler
  return next(authReq);
};
</code></pre>
                        <p class="h5">3. Global Error Handling</p>
                        <p>Interceptors are the perfect place to catch HTTP errors using the RxJS
                            <code>catchError</code> operator. This prevents your services from becoming cluttered with
                            repetitive <code>try/catch</code> logic.
                        </p>
                        <pre><code class="language-javascript">import { HttpInterceptorFn } from '@angular/common/http';
import { catchError, throwError } from 'rxjs';

export const errorInterceptor: HttpInterceptorFn = (req, next) =&gt; {
  return next(req).pipe(
    catchError((error) =&gt; {
      if (error.status === 401) {
        console.error('User is unauthorized. Redirecting to login...');
        // Logic to redirect or refresh token
      }
      
      const errorMessage = error.error?.message || 'A mysterious server error occurred';
      return throwError(() =&gt; new Error(errorMessage));
    })
  );
};
</code></pre>
                        <p class="h5">4. Registering Interceptors</p>
                        <p>Interceptors must be registered in the application configuration using the
                            <code>withInterceptors</code> helper inside <code>provideHttpClient</code>.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Configuration Location</th>
                                        <th scope="col">Implementation</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">File</th>
                                        <td><code>app.config.ts</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Method</th>
                                        <td>
                                            <code>provideHttpClient(withInterceptors([authInterceptor, errorInterceptor]))</code>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h6">Example:</p>
                        <pre><code class="language-javascript">export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withInterceptors([authInterceptor, errorInterceptor])
    )
  ]
};
</code></pre>
                        <p class="h6">Common Use Cases for Interceptors</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Use Case</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Authentication</strong></td>
                                        <td>Automatically attach JWT tokens to every request.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Logging</strong></td>
                                        <td>Log the duration of HTTP requests for performance monitoring.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Base URL</strong></td>
                                        <td>Prepend a base API URL so services can use relative paths (e.g.,
                                            <code>/users</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><strong>Retry Logic</strong></td>
                                        <td>Automatically retry a request if it fails due to a network glitch.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Caching</strong></td>
                                        <td>Store responses locally and return them immediately for subsequent requests.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p> The order of interceptors in the <code>withInterceptors</code> array matters.
                                    Angular executes them in the order they are listed for requests, and in reverse
                                    order for responses.</p>
                            </div>
                        </div>
                        <p>Warning: Be careful when logging request bodies or headers in production. Interceptors have
                            access to sensitive data like passwords and credit card numbers. Always ensure your logging
                            logic filters out "PII" (Personally Identifiable Information).</p>
                    </section>

                    <section class="docs-section" id="item-8-4">
                        <p class="h3">Server-Side Rendering (SSR) & Hydration</p>
                        <p>Server-Side Rendering (SSR) is the process where Angular generates the HTML for your pages on
                            a server in response to a request, rather than rendering everything in the browser. When the
                            browser receives this pre-rendered HTML, it can display the page content immediately, even
                            before the JavaScript bundles have finished downloading.</p>
                        <p class="h5">Why use SSR?</p>
                        <p>While standard Client-Side Rendering (CSR) is great for interactive apps, SSR solves two
                            major challenges:</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Benefit</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">SEO Optimization</th>
                                        <td>Search engine crawlers (like Google or Bing) can easily read the
                                            pre-rendered HTML, ensuring better indexing and ranking.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Social Media</th>
                                        <td>Enables "Rich Previews" (Open Graph cards) when links are shared on
                                            platforms like X, Facebook, or LinkedIn.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Performance (FCP)</th>
                                        <td>Improves <strong>First Contentful Paint</strong>. Users see the site content
                                            almost instantly, even on slow devices or networks.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">Hydration: The "Second Act"</p>
                        <p>In the past, SSR caused a "flicker" where the server-rendered page would disappear and be
                            replaced by the client-rendered version. Modern Angular (v16+) uses Hydration.</p>
                        <ul>
                            <li>The Concept: Instead of destroying the server HTML, Angular "wakes it up." It reconciles
                                the existing DOM nodes with the Angular component tree and attaches event listeners.
                            </li>
                            <li>The Result: A seamless transition from static HTML to a fully interactive application
                                with no layout shifts or visual glitches.</li>
                        </ul>
                        <p class="h5">1. Enabling SSR & Hydration</p>
                        <p>In modern Angular (v17+), you can enable SSR during project creation or add it later. To
                            enable hydration, you add <code>provideClientHydration()</code> to your providers.</p>
                        <pre><code class="language-javascript">// app.config.ts
import { provideClientHydration } from '@angular/platform-browser';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    provideHttpClient(withFetch()), // Fetch is recommended for SSR
    provideClientHydration()       // Enables Hydration
  ]
};
</code></pre>
                        <p class="h5">2. Common SSR Challenges</p>
                        <p>Since your code now runs in two environments (Node.js on the server and the Browser), you
                            must be careful with platform-specific APIs.</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Browser API</th>
                                        <th scope="col">SSR Equivalent/Solution</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>
                                            <code>window</code>, <code>document</code>, <code>localStorage</code>
                                        </td>
                                        <td>
                                            These do not exist on the server. Accessing them directly will crash your
                                            app.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <code>setTimeout</code>, <code>setInterval</code>
                                        </td>
                                        <td>
                                            Can cause the server to hang if not cleared properly.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><strong>Solution</strong></td>
                                        <td>
                                            Use <code>isPlatformBrowser</code> or <code>isPlatformServer</code> to wrap
                                            specific code.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h6">Example of Platform Checking:</p>
                        <pre><code class="language-javascript">import { PLATFORM_ID, inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';

export class MyComponent {
  private platformId = inject(PLATFORM_ID);

  ngOnInit() {
    if (isPlatformBrowser(this.platformId)) {
      // Safe to use localStorage or window here
      console.log(window.location.href);
    }
  }
}
</code></pre>
                        <p class="h5">3. Transfer State</p>
                        <p>To prevent the app from fetching the same data twice (once on the server to render and once
                            on the client to initialize), Angular uses Transfer State. The server serializes the API
                            data into a script tag in the HTML, and the client "picks it up" instead of making a new
                            HTTP call.</p>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>When using <code>HttpClient</code>, Angular handles much of this Transfer State logic
                                    automatically if hydration is enabled.</p>
                            </div>
                        </div>
                        <p>Warning: Avoid direct DOM manipulation (e.g., <code>document.querySelector</code>) when using
                            SSR. Always use Angular's <code>Renderer2</code> or <code>ElementRef</code>. Direct DOM
                            access bypasses the abstraction layer that allows Angular to run on the server, leading to
                            inconsistent states and hydration errors.</p>
                    </section>

                    <section class="docs-section" id="item-8-5">
                        <p class="h3">Static Site Generation (SSG)</p>
                        <p>While SSR generates pages on-demand for every request, Static Site Generation (SSG) (often
                            called "Prerendering" in Angular) shifts that work to build time. Every route is converted
                            into a static HTML file before the application is even deployed to a server.
                        </p>
                        <p class="h5">How SSG Works</p>
                        <p>When you build an Angular app with SSG enabled:</p>
                        <ol>
                            <li>The build engine crawls your defined routes.</li>
                            <li>It renders each route into a complete HTML document.</li>
                            <li>These files are saved in the <code>dist</code> folder.</li>
                            <li>When a user visits <code>/about</code>, the web server serves the pre-generated
                                <code>about/index.html</code> file instantly.
                            </li>
                        </ol>
                        <p class="h6">SSG vs. SSR vs. CSR</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">CSR (Client-Side)</th>
                                        <th scope="col">SSR (Server-Side)</th>
                                        <th scope="col">SSG (Static Site)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Render Time</th>
                                        <td>Runtime (Browser)</td>
                                        <td>Runtime (Server)</td>
                                        <td><strong>Build Time</strong></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Server Load</th>
                                        <td>Low</td>
                                        <td>High (Render on every hit)</td>
                                        <td><strong>Very Low (Static files)</strong></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Data Freshness</th>
                                        <td>Live</td>
                                        <td>Live</td>
                                        <td>Snapshot (from build)</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Best For</th>
                                        <td>Dashboards, Tools</td>
                                        <td>E-commerce, Dynamic SEO</td>
                                        <td><strong>Blogs, Documentation</strong></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">1. Enabling SSG in Angular</p>
                        <p>In modern Angular (v17+), SSG is often bundled with the SSR configuration. If you used
                            <code>ng add @angular/ssr</code>, SSG is available by default. To trigger it during the
                            build, you use:
                        </p>
                        <pre><code class="language-bash">ng build
</code></pre>
                        <p>This will produce a <code>browser</code> folder containing static assets and a
                            <code>server</code> folder for the rendering engine. If a route doesn't have dynamic
                            parameters, Angular will automatically attempt to prerender it.
                        </p>
                        <p class="h6">2. Handling Dynamic Routes</p>
                        <p>For routes like <code>/product/:id</code>, the build engine doesn't know which IDs exist. To
                            prerender these, you must provide a list of paths in a text file or via a script.
                        </p>
                        <p class="h6">Example <code>routes.txt:</code></p>
                        <pre><code class="language-javascript ">/home
/about
/product/1
/product/2
/product/42
   </code></pre>
                        <p>You then tell the Angular CLI to use this file:</p>
                        <pre><code class="language-javascript">ng build --prerender --routes-file routes.txt
</code></pre>
                        <p class="h5">3. Pros and Cons of SSG</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Advantages</th>
                                        <th scope="col">Disadvantages</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>
                                            <strong>Insane Speed:</strong> No server-side processing; files are served
                                            from a CDN.
                                        </td>
                                        <td>
                                            <strong>Stale Data:</strong> If content changes in the database, you must
                                            rebuild the site.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <strong>Security:</strong> No server-side code running, reducing the attack
                                            surface.
                                        </td>
                                        <td>
                                            <strong>Build Times:</strong> A site with 10,000 products can take a long
                                            time to build.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <strong>Zero-Config Hosting:</strong> Can be hosted on GitHub Pages,
                                            Netlify, or S3.
                                        </td>
                                        <td>
                                            <strong>Dynamic Content:</strong> Harder to handle user-specific data (e.g.,
                                            a "Profile" page).
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">4. Hybrid Strategy</p>
                        <p>Most modern Angular apps use a Hybrid Approach:</p>
                        <ul>
                            <li>SSG for static marketing pages (Home, About, Contact).</li>
                            <li>SSR for dynamic, SEO-sensitive pages (Search results, Product details).</li>
                            <li>CSR for protected, interactive areas (User Dashboard, Settings).</li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p> If you are using SSG and your data changes frequently, consider using a Webhook.
                                    When your CMS data changes, the Webhook can trigger a new build on your CI/CD
                                    pipeline (e.g., GitHub Actions) to refresh the static files.</p>
                            </div>
                        </div>
                        <p>Warning: Be cautious with "flash of unstyled content" or state mismatches. If your static
                            HTML shows "Welcome, Guest" but the user is actually logged in, the client-side hydration
                            will abruptly swap the text once the JavaScript loads. For user-specific data, it is often
                            better to leave that area blank or show a skeleton loader in the static version.
                        </p>
                    </section>
                </article>

                <article class="docs-article" id="section-9">
                    <header class="docs-header">
                        <p class="h2 docs-heading">Section 9: Advanced Topics</p>
                    </header>
                    <hr>
                    <section class="docs-section" id="item-9-1">
                        <p class="h3">Observables & RxJS in Angular</p>
                        <p>RxJS (Reactive Extensions for JavaScript) is a library for composing asynchronous and
                            event-based programs using observable sequences. While Angular provides standard tools for
                            many tasks, Observables are the backbone of its asynchronous logic, used in everything from
                            the <code>HttpClient</code> to the Router and Form value changes.
                        </p>
                        <p>Think of an Observable as a stream of data that can arrive over time. Unlike a Promise, which
                            handles a single event and then finishes, an Observable can emit multiple values, stay open
                            indefinitely, or be canceled.</p>
                        <p class="h5">Core Concepts of RxJS</p>
                        <p>To work effectively with RxJS in Angular, you must understand these four pillars:</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Concept</th>
                                        <th scope="col">Description</th>
                                        <th scope="col">Analogy</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Observable</th>
                                        <td>The data source that emits values over time.</td>
                                        <td>A YouTube Channel.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Observer</th>
                                        <td>The object that listens to and handles the data.</td>
                                        <td>A Subscriber.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Subscription</th>
                                        <td>The execution that connects the Observer to the Observable.</td>
                                        <td>The act of hitting the "Subscribe" button.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Operators</th>
                                        <td>Functions that allow you to transform or filter the data stream.</td>
                                        <td>Video filters or playback speed settings.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">1. The Observable Lifecycle</p>
                        <p>An Observable can emit three types of notifications:</p>
                        <ul>
                            <li>Next: A new value is pushed into the stream (can happen 0 to infinite times).</li>
                            <li>Error: A failure occurred. The stream stops immediately.</li>
                            <li>Complete: The stream has finished successfully. No more values will arrive.</li>
                        </ul>
                        <pre><code class="language-javascript">import { Observable } from 'rxjs';

const myObservable = new Observable(subscriber =&gt; {
  subscriber.next('Hello');
  subscriber.next('World');
  subscriber.complete();
});

// Nothing happens until you subscribe
myObservable.subscribe({
  next: (val) =&gt; console.log(val),
  error: (err) =&gt; console.error(err),
  complete: () =&gt; console.log('Done!')
});
</code></pre>
                        <p class="h5">2. Common RxJS Operators</p>
                        <p>Operators are the true power of RxJS. They allow you to manipulate data streams with
                            declarative logic. They are used within the <code>.pipe()</code> method.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Operator</th>
                                        <th scope="col">Category</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>map</code></td>
                                        <td>Transformation</td>
                                        <td>Transforms each emitted value (like <code>Array.map</code>).</td>
                                    </tr>
                                    <tr>
                                        <td><code>filter</code></td>
                                        <td>Filtering</td>
                                        <td>Only lets values through that meet a condition.</td>
                                    </tr>
                                    <tr>
                                        <td><code>switchMap</code></td>
                                        <td>Transformation</td>
                                        <td>Cancels the previous inner observable and switches to a new one (perfect for
                                            search inputs).</td>
                                    </tr>
                                    <tr>
                                        <td><code>take(n)</code></td>
                                        <td>Filtering</td>
                                        <td>Emits only the first <code>n</code> values and then completes.</td>
                                    </tr>
                                    <tr>
                                        <td><code>catchError</code></td>
                                        <td>Error Handling</td>
                                        <td>Gracefully handles errors in the stream.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">3. Subject vs. BehaviorSubject</p>
                        <p>In Angular, we often need to "multicast" data—sending the same value to multiple parts of the
                            app. For this, we use Subjects.
                        </p>
                        <ul>
                            <li>Subject: A basic "event bus." Subscribers only receive values emitted after they
                                subscribe.
                            </li>
                            <li>BehaviorSubject: Stores the current value. New subscribers immediately receive the most
                                recent value upon subscribing. This is the standard for State Management.
                            </li>
                        </ul>
                        <pre><code class="language-javascript">import { BehaviorSubject } from 'rxjs';

// Initial value is 'Initial State'
const state$ = new BehaviorSubject&lt;string&gt;('Initial State');

// Component A subscribes and gets 'Initial State'
state$.subscribe(console.log);

// Update the state
state$.next('New State'); 

// Component B subscribes now and immediately gets 'New State'
</code></pre>
                        <p class="h5">4. Managing Subscriptions (Memory Leaks)</p>
                        <p>A major pitfall in Angular is forgetting to unsubscribe. If a component is destroyed but the
                            subscription stays open, it creates a memory leak.</p>
                        <ul>
                            <li>Manual: Use <code>subscription.unsubscribe()</code> in <code>ngOnDestroy</code>.</li>
                            <li>Declarative: Use the <code>takeUntilDestroyed()</code> pipe (Angular 16+).</li>
                            <li>Automatic (Best Practice): Use the AsyncPipe (<code>| async</code>) in your HTML
                                templates. It handles subscribing and unsubscribing automatically.</li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Use the $ suffix (e.g., <code>data$</code>) as a naming convention for variables that
                                    are Observables. This helps you and your team quickly identify which variables need
                                    to be subscribed to or piped.</p>
                            </div>
                        </div>
                        <p>Warning: Avoid "Nested Subscriptions" (subscribing inside a subscribe block). This makes code
                            hard to read and manage. Instead, use "Flattening Operators" like <code>switchMap</code>,
                            <code>mergeMap</code>, or <code>concatMap</code> to chain asynchronous actions together.
                        </p>
                    </section>

                    <section class="docs-section" id="item-9-2">
                        <p class="h3">Animations</p>
                        <p>Angular’s animation system is built on top of Web Animations API (WAA), which means it is
                            performant and runs in the browser’s hardware-accelerated layers. Rather than manually
                            toggling CSS classes, Angular allows you to define states and transitions directly within
                            your component, enabling a declarative way to create complex, coordinated motion.
                        </p>
                        <p class="h5">1. Configuration (Setup)</p>
                        <p>To use animations, you must provide the animation engine to your application configuration.
                            This enables the browser to listen for animation triggers in your templates.</p>
                        <pre><code class="language-javascript">// app.config.ts
import { provideAnimations } from '@angular/platform-browser/animations';

export const appConfig: ApplicationConfig = {
  providers: [
    provideAnimations() // Or provideNoopAnimations() for testing/disabling
  ]
};
</code></pre>
                        <p class="h5">2. The Core Animation Functions</p>
                        <p>Angular animations are defined inside the <code>@Component</code> decorator using a set of
                            specific functions.</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped border">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col" style="width: 25%;">Function</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>trigger()</code></td>
                                        <td>The name of the animation (e.g., <code>'fade'</code>) used in the HTML.</td>
                                    </tr>
                                    <tr>
                                        <td><code>state()</code></td>
                                        <td>Defines a set of CSS styles for a specific naming (e.g.,
                                            <code>'open'</code>, <code>'closed'</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>transition()</code></td>
                                        <td>Defines the timing and order of styles when moving between states.</td>
                                    </tr>
                                    <tr>
                                        <td><code>animate()</code></td>
                                        <td>Sets the duration, delay, and easing (e.g., <code>'300ms ease-in'</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>style()</code></td>
                                        <td>A set of CSS properties applied immediately.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">3. Creating a Basic Animation</p>
                        <p>In this example, we create a "fade-in/out" effect that toggles based on a boolean property.
                        </p>
                        <pre><code class="language-javascript">import { trigger, state, style, animate, transition } from '@angular/animations';

@Component({
  selector: 'app-fade',
  standalone: true,
  animations: [
    trigger('fadeInOut', [
      state('open', style({ opacity: 1 })),
      state('closed', style({ opacity: 0 })),
      transition('open =&gt; closed', [animate('0.5s')]),
      transition('closed =&gt; open', [animate('0.2s')])
    ])
  ],
  template: `
    &lt;div [@fadeInOut]="isOpen ? 'open' : 'closed'"&gt;
      Look at me fade!
    &lt;/div&gt;
    &lt;button (click)="isOpen = !isOpen"&gt;Toggle&lt;/button&gt;
  `
})
export class FadeComponent {
  isOpen = true;
}
</code></pre>
                        <p class="h5">4. Enter and Leave Aliases</p>
                        <p>One of the most powerful features of Angular animations is the ability to animate elements as
                            they are added to or removed from the DOM (e.g., via <code>*ngIf</code> or
                            <code>@if</code>).
                        </p>
                        <ul>
                            <li><code>:enter</code>: Alias for <code>void => *</code> (from "nothing" to any state).
                            </li>
                            <li><code>:leave</code>: Alias for <code>* => void</code> (from any state to "nothing").
                            </li>
                        </ul>
                        <pre><code class="language-javascript">trigger('listAnimation', [
  transition(':enter', [
    style({ opacity: 0, transform: 'translateY(-10px)' }),
    animate('300ms ease-out', style({ opacity: 1, transform: 'translateY(0)' }))
  ]),
  transition(':leave', [
    animate('200ms ease-in', style({ opacity: 0, scale: 0.5 }))
  ])
])
</code></pre>
                        <p class="h5">5. Advanced Techniques</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Technique</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>query()</code></td>
                                        <td>Targets specific child elements within the main trigger to animate them
                                            individually.</td>
                                    </tr>
                                    <tr>
                                        <td><code>stagger()</code></td>
                                        <td>Creates a delay between multiple child animations (perfect for lists).</td>
                                    </tr>
                                    <tr>
                                        <td><code>group()</code></td>
                                        <td>Runs multiple animations in parallel.</td>
                                    </tr>
                                    <tr>
                                        <td><code>sequence()</code></td>
                                        <td>Runs multiple animations one after the other (default).</td>
                                    </tr>
                                    <tr>
                                        <td><code>keyframe()</code></td>
                                        <td>Allows for multi-step animations (like CSS <code>@keyframes</code>).</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>For simple hover effects or standard transitions, plain CSS is often faster and
                                    easier. Use Angular Animations when the motion depends on application state,
                                    component lifecycle events, or when you need to coordinate multiple elements
                                    simultaneously.
                                </p>
                            </div>
                        </div>
                        <p>Warning: Animation triggers can be "blocked" by parents. If a parent element has an animation
                            running, child animations may be disabled unless you specifically use the animateChild()
                            function. This ensures that a parent closing an entire menu doesn't get "stuck" waiting for
                            a tiny button inside to finish its own exit animation.
                        </p>
                    </section>
                    <section class="docs-section" id="item-9-3">
                        <p class="h3">Internationalization (i18n)</p>
                        <p>Internationalization, commonly abbreviated as i18n, is the process of designing and preparing
                            your application to support multiple languages and regions. Angular provides a built-in
                            framework that allows you to mark text for translation, extract it into standard translation
                            files, and build separate versions of your app for different locales.
                        </p>
                        <p class="h5">1. Marking Text for Translation</p>
                        <p>To mark a piece of text as translatable, you use the <code>i18n</code> attribute. This is a
                            "custom attribute" that is recognized by the Angular compiler but does not remain in the
                            final HTML.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Attribute Component</th>
                                        <th scope="col">Description</th>
                                        <th scope="col">Example</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Meaning</th>
                                        <td>High-level intent/context.</td>
                                        <td><code>i18n="User Dashboard"</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Description</th>
                                        <td>Specific details for the translator.</td>
                                        <td><code>i18n="@@homeHeader"</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Custom ID</th>
                                        <td>(Optional) Permanent ID for the string.</td>
                                        <td><code>@@myUniqueId</code></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h6">Example:</p>
                        <pre><code class="language-javascript">&lt;h1 i18n="site header|Welcome message for the homepage@@welcomeHeader"&gt;
  Welcome to our store!
&lt;/h1&gt;
</code></pre>
                        <p class="h5">2. Translating Attributes and Plurals</p>
                        <p>You aren't limited to plain text; you can also translate HTML attributes and handle complex
                            pluralization logic using ICU (International Components for Unicode) expressions.
                        </p>
                        <p class="h6">Attribute Translation</p>
                        <p>To translate an attribute like <code>title</code> or <code>placeholder</code>, use the syntax
                            <code>i18n-attributeName</code>.
                        </p>
                        <pre><code class="language-html">&lt;img src="logo.png" i18n-alt alt="Company Logo"&gt;
</code></pre>
                        <p class="h6">Pluralization and Selection</p>
                        <p>ICU expressions handle different grammatical rules for numbers (Plural) or genders/categories
                            (Select).</p>
                        <pre><code class="language-html">&lt;span i18n&gt;
  {itemCount, plural, =0 {no items} =1 {one item} other {{itemCount} items}}
&lt;/span&gt;

&lt;span i18n&gt;
  The user is {gender, select, male {man} female {woman} other {person}}
&lt;/span&gt;
</code></pre>
                        <p class="h5">3. The i18n Workflow</p>
                        <p>Angular uses a "compile-time" translation strategy. This means the translations are baked
                            into the application during the build process, resulting in highly performant,
                            pre-translated bundles for each language.
                        </p>
                        <ol>
                            <li>Extract: Run <code>ng extract-i18n</code>. This creates a source file (usually
                                <code>.xlf</code>) containing all marked strings.
                            </li>
                            <li>Translate: Send the <code>.xlf</code> file to translators. They provide a translated
                                version (e.g., <code>messages.fr.xlf</code>).</li>
                            <li>Build: Configure your <code>angular.json</code> to build specific locales.
                            </li>
                        </ol>
                        <pre><code class="language-javascript">// angular.json snippet
"i18n": {
  "sourceLocale": "en-US",
  "locales": {
    "fr": "src/locale/messages.fr.xlf",
    "es": "src/locale/messages.es.xlf"
  }
}
</code></pre>
                        <p class="h5">4. Localizing Pipes</p>
                        <p>Angular’s built-in pipes (Date, Currency, Percent, etc.) automatically use the locale data of
                            the environment they are running in.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Pipe</th>
                                        <th scope="col">Default (en-US)</th>
                                        <th scope="col">Localized (fr-FR)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Date</th>
                                        <td>02/19/2026</td>
                                        <td>19/02/2026</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Currency</th>
                                        <td>$1,234.56</td>
                                        <td>1 234,56 €</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Decimal</th>
                                        <td>1,000.5</td>
                                        <td>1 000,5</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p>To use these correctly, you must ensure the locale data is registered in your
                            <code>app.config.ts</code> or provided via the <code>LOCALE_ID</code> token.
                        </p>
                        <p class="h5">5. Runtime i18n (Optional)</p>
                        <p>While the built-in Angular i18n is the most performant, some teams prefer Runtime Translation
                            (switching languages without a page reload). For this, third-party libraries like
                            @ngx-translate/core or Transloco are popular alternatives.</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Approach</th>
                                        <th scope="col">Performance</th>
                                        <th scope="col">SEO</th>
                                        <th scope="col">Ease of Use</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Built-in i18n</th>
                                        <td><strong>Best</strong> (Compiled)</td>
                                        <td>Excellent</td>
                                        <td>Moderate</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Runtime (ngx-translate)</th>
                                        <td>Slower (Loaded at run)</td>
                                        <td>Requires SSR</td>
                                        <td><strong>Easiest</strong></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p> When using the built-in i18n, your web server (like Nginx or Apache) must be
                                    configured to serve the correct language bundle based on the user's browser settings
                                    or the URL (e.g., <code>mysite.com/fr/</code>).</p>
                            </div>
                        </div>
                        <p>Warning: Never use string concatenation for translatable strings (e.g., <code>i18n</code> +
                            <code>variable</code>). Different languages have different word orders. Always use the full
                            sentence or ICU expressions so translators can reorder the variables as needed for their
                            specific grammar rules.
                        </p>
                    </section>

                    <section class="docs-section" id="item-9-4">
                        <p class="h3">Web Workers</p>
                        <p>In a standard Angular application, all tasks—including UI rendering, event handling, and
                            complex calculations—run on a single thread called the Main Thread. If you perform a heavy
                            computation (like processing a massive dataset or generating a complex PDF), the main thread
                            "freezes," making the UI unresponsive and frustrating users.
                        </p>
                        <p>Web Workers solve this by allowing you to run scripts in a background thread. This keeps the
                            main thread free to handle the UI, ensuring smooth animations and instant button clicks.
                        </p>
                        <p class="h5">When to Use Web Workers</p>
                        <p>Web Workers are powerful, but they come with overhead. You should only use them for "heavy
                            lifting" tasks.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover ">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Recommended Use Cases</th>
                                        <th scope="col">Not Recommended For</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Image/Video processing</td>
                                        <td>Simple UI updates.</td>
                                    </tr>
                                    <tr>
                                        <td>Large-scale data filtering</td>
                                        <td>Small API calls.</td>
                                    </tr>
                                    <tr>
                                        <td>Complex mathematical algorithms</td>
                                        <td>Basic form validation.</td>
                                    </tr>
                                    <tr>
                                        <td>Parsing huge JSON files</td>
                                        <td>Routine state management.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">1. Generating a Web Worker in Angular</p>
                        <p>The Angular CLI makes setting up Web Workers straightforward. You can generate one for a
                            specific component using the following command:</p>
                        <pre><code class="language-bash">ng generate web-worker app
</code></pre>
                        <p>This command does three things:</p>
                        <ul>
                            <li>Creates a <code>tsconfig.worker.json</code>.</li>
                            <li>Updates <code>angular.json</code> to support worker builds.</li>
                            <li>Creates an <code>app.worker.ts</code> file.</li>
                        </ul>
                        <p class="h5">2. Implementation: The Worker Script</p>
                        <p>The worker lives in its own file. It cannot access the DOM or Angular services directly.
                            Communication happens via a Messaging System.</p>
                        <pre><code class="language-javascript">/// &lt;reference lib="webworker" /&gt;

// app.worker.ts
addEventListener('message', ({ data }) =&gt; {
  // Heavy computation starts here
  const result = performHeavyCalculation(data);
  
  // Send the result back to the main thread
  postMessage(result);
});

function performHeavyCalculation(data: any) {
  // Imagine a loop running 1 billion times
  return `Processed: ${data}`;
}
</code></pre>
                        <p class="h5">3. Using the Worker in a Component</p>
                        <p>In your TypeScript component, you instantiate the worker and listen for messages.</p>
                        <pre><code class="language-javascript">if (typeof Worker !== 'undefined') {
  // Create a new web worker
  const worker = new Worker(new URL('./app.worker', import.meta.url));

  // Listen for the results
  worker.onmessage = ({ data }) =&gt; {
    console.log('Page got message:', data);
  };

  // Send data to the worker to start the job
  worker.postMessage('hello');
} else {
  // Web Workers are not supported in this environment (fallback logic)
}
</code></pre>
                        <p class="h5">Key Constraints of Web Workers</p>
                        <p>Because Web Workers run in a completely separate context from the main application, they have
                            strict limitations:</p>
                        <ul>
                            <li>No DOM Access: You cannot use <code>document.querySelector</code> or change CSS within a
                                worker.</li>
                            <li>No <code>window</code> Object: You cannot access <code>window.localStorage</code> or
                                <code>window.location</code>.
                            </li>
                            <li>Isolated State: Workers don't share variables with your Angular components. You must
                                pass data back and forth using Structured Cloning (which copies the data, rather than
                                sharing a reference).</li>
                            <li>No Angular Services: You cannot inject services into a worker file.</li>
                        </ul>
                        <p class="h6">Performance Tip: Offloading Data</p>
                        <p>If you are passing massive amounts of data (like an <code>ArrayBuffer</code>), use
                            Transferable Objects. This "transfers" the memory from the main thread to the worker without
                            copying it, making the process nearly instantaneous.</p>
                        <pre><code class="language-javascript">// Transferring ownership of an ArrayBuffer
worker.postMessage(largeBuffer, [largeBuffer]);
</code></pre>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Modern Angular (v17+) and the Esbuild-based builder have optimized Web Worker
                                    support, making them much faster to bundle and load than in previous versions.</p>
                            </div>
                        </div>
                        <p>Warning: Don't overuse Web Workers. Creating a worker has a memory and startup cost. If your
                            task takes less than 50ms, it's usually better to keep it on the main thread.</p>
                    </section>

                    <section class="docs-section" id="item-9-5">
                        <p class="h3">Angular Elements (Web Components)</p>
                        <p>Angular Elements is a feature that allows you to package Angular components as Custom
                            Elements (part of the Web Components standard). Once packaged, these components can be used
                            in any HTML environment—whether it's a plain HTML file, a React app, a Vue project, or even
                            a legacy jQuery site—without needing the full Angular framework overhead in the host
                            environment.</p>
                        <p class="h5">Why use Angular Elements?</p>
                        <p>Angular Elements bridge the gap between Angular’s rich ecosystem and the universal web
                            standards.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Use Case</th>
                                        <th scope="col">Benefit</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Micro-frontends</th>
                                        <td>Different teams can build parts of a page in different frameworks, sharing
                                            Angular-built UI components.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">CMS Integration</th>
                                        <td>Embed complex dynamic components (like a calculator or dashboard) into
                                            static CMS pages (WordPress, Drupal).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Design Systems</th>
                                        <td>Build a component library once in Angular and distribute it to teams using
                                            other tech stacks.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Partial Migration</th>
                                        <td>Gradually migrate a legacy app to Angular by replacing small pieces with
                                            Angular Elements.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">1. Setup and Installation</p>
                        <p>To get started, you need to add the <code>@angular/elements</code> package to your project.
                            This package provides the <code>createCustomElement</code> API.</p>
                        <pre><code class="language-bash">ng add @angular/elements
</code></pre>
                        <p class="h5">2. Converting a Component</p>
                        <p>To transform a standard Standalone Component into a Custom Element, you use the
                            <code>createCustomElement</code> function and define it using the browser's native
                            <code>customElements.define</code> API.
                        </p>
                        <pre><code class="language-javascript">import { createCustomElement } from '@angular/elements';
import { Injector, createComponent } from '@angular/core';
import { MyButtonComponent } from './my-button.component';

// Inside your main.ts or an initialization service
const injector = inject(Injector);

// 1. Create a constructor class from the component
const myElement = createCustomElement(MyButtonComponent, { injector });

// 2. Register the custom element with the browser
customElements.define('my-button-element', myElement);
</code></pre>
                        <p class="h5">3. Using the Element Anywhere</p>
                        <p>Once registered, you use the component just like a native HTML tag. The browser handles the
                            lifecycle, and Angular handles the internal logic.</p>
                        <pre><code class="language-html">&lt;my-button-element label="Click Me" (action)="handleEvent($event)"&gt;&lt;/my-button-element&gt;

&lt;script&gt;
  const el = document.querySelector('my-button-element');
  el.addEventListener('action', (event) =&gt; {
    console.log('Angular element said:', event.detail);
  });
&lt;/script&gt;
</code></pre>
                        <p class="h6">Mapping Strategy: How Data Flows</p>
                        <p>Angular automatically maps your component's class properties to the Custom Element's
                            interface.</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Angular Feature</th>
                                        <th scope="col">Web Component Equivalent</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>@Input()</code></td>
                                        <td>
                                            Becomes an <strong>HTML Attribute/Property</strong>. Updates trigger
                                            change detection.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>@Output()</code></td>
                                        <td>
                                            Becomes a <strong>Custom Event</strong>. Dispatched via
                                            <code>dispatchEvent()</code>.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>Lifecycle Hooks</td>
                                        <td>
                                            Mapped to <strong>Custom Element Reactions</strong> (e.g.,
                                            <code>connectedCallback</code>).
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>Encapsulation</td>
                                        <td>
                                            Works best with <code>ViewEncapsulation.ShadowDom</code> for true
                                            CSS isolation.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">4. Technical Considerations</p>
                        <ul>
                            <li>Bundle Size: Even though it's a "Web Component," it still requires a version of the
                                Angular runtime to function. If you have many separate Angular Elements on one page,
                                they can share the runtime to save space.</li>
                            <li>Shadow DOM: It is highly recommended to set
                                <code>encapsulation: ViewEncapsulation.ShadowDom</code> in your component metadata. This
                                ensures that styles from the host page don't "leak" into your component and vice versa.
                            </li>
                            <li>Zone.js: Custom Elements traditionally rely on Zone.js for change detection. However, in
                                modern Angular (v18+), you can build Zoneless Angular Elements for even better
                                performance and smaller footprints.</li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>To distribute an Angular Element as a single file, you often need to use a build tool
                                    (like <code>ngx-build-plus</code> or a custom esbuild script) to concatenate the
                                    resulting JavaScript chunks into one <code>my-component.js</code> file.</p>
                            </div>
                        </div>
                        <p>Warning: Custom Elements use "Kebab-case" for attributes in HTML, but Angular uses
                            "CamelCase" for inputs. When using your element in plain HTML, <code>[myInput]</code>
                            becomes <code>my-input</code>. Ensure your naming conventions are consistent to avoid silent
                            binding failures.
                        </p>
                    </section>

                    <section class="docs-section" id="item-9-6">
                        <p class="h3">Security (Sanitization & XSS)</p>
                        <p>Security is a core pillar of the Angular framework. By default, Angular treats all values as
                            untrusted and automatically sanitizes data to prevent Cross-Site Scripting (XSS) attacks—a
                            common vulnerability where attackers inject malicious scripts into web pages viewed by other
                            users.
                        </p>
                        <p class="h5">1. Built-in Sanitization</p>
                        <p>Angular provides automatic sanitization for several security contexts. When you bind a value
                            to the DOM (via property, attribute, style, or class binding), Angular identifies the
                            context and sanitizes the value accordingly.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Security Context</th>
                                        <th scope="col">Description</th>
                                        <th scope="col">Examples</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">HTML</th>
                                        <td>Used when interpreting a value as HTML.</td>
                                        <td><code>[innerHTML]</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Style</th>
                                        <td>Used when binding CSS to styles.</td>
                                        <td><code>[style.background-image]</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">URL</th>
                                        <td>Used for external links.</td>
                                        <td><code>&lt;a [href]="..."&gt;</code></td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Resource URL</th>
                                        <td>Used for code that will be loaded/executed.</td>
                                        <td>
                                            <code>&lt;script [src]="..."&gt;</code>,<br>
                                            <code>&lt;iframe [src]="..."&gt;</code>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h6">Example of Automatic Blocking:</p>
                        <p>If an attacker tries to bind <code>&lt;script&gt;alert("Hacked")&lt;/script&gt;</code> to
                            <code>[innerHTML]</code>, Angular will strip the <code>&lt;script&gt;</code> tag but keep
                            the safe text, rendering it harmless.
                        </p>
                        <p class="h5">2. Bypassing Security (DomSanitizer)</p>
                        <p>Sometimes, you genuinely need to include "unsafe" content, such as an embedded YouTube iframe
                            or dynamic CSS from a trusted source. For these cases, Angular provides the
                            <code>DomSanitizer</code> service.
                        </p>
                        <pre><code class="language-javascript">import { Component, inject } from '@angular/core';
import { DomSanitizer, SafeResourceUrl } from '@angular/platform-browser';

@Component({
  selector: 'app-secure-video',
  template: `&lt;iframe [src]="safeUrl"&gt;&lt;/iframe&gt;`
})
export class SecureVideoComponent {
  private sanitizer = inject(DomSanitizer);
  // We must explicitly mark this URL as trusted
  safeUrl: SafeResourceUrl = this.sanitizer.bypassSecurityTrustResourceUrl('https://www.youtube.com/embed/dQw4w9WgXcQ');
}
</code></pre>
                        <p class="h5">3. Common Security Threats and Defenses</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Threat</th>
                                        <th scope="col">Angular's Defense</th>
                                        <th scope="col">Best Practice</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">XSS</th>
                                        <td>Automatic output escaping and sanitization.</td>
                                        <td>Avoid using <code>ElementRef</code> to manipulate the DOM directly.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">CSRF</th>
                                        <td><code>HttpClient</code> has built-in support for XSRF tokens.</td>
                                        <td>Ensure your backend sends a <code>XSRF-TOKEN</code> cookie.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Open Redirect</th>
                                        <td>No built-in defense for logic.</td>
                                        <td>Never use user-provided input directly in <code>router.navigate</code>.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Template Injection</th>
                                        <td>Offline template compilation (AOT).</td>
                                        <td>Never generate templates dynamically from user input.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">4. Best Practices for a Secure App</p>
                        <ul>
                            <li>Avoid the "Bypass" methods: Only use <code>bypassSecurityTrust</code>... as a last
                                resort. If you must use it, ensure the input is strictly validated or comes from your
                                own trusted database.</li>
                            <li>Use AOT Compilation: Ahead-of-Time compilation prevents many "template injection"
                                attacks because templates are converted to code during build time, not in the browser.
                            </li>
                            <li>Content Security Policy (CSP): Implement a strong CSP header on your server to restrict
                                which scripts, styles, and images can be loaded by the browser.</li>
                            <li>Stay Updated: Security vulnerabilities are often discovered in libraries. Regularly run
                                <code>npm audit</code> and keep Angular updated to the latest version.
                            </li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Note: Angular does not protect your Backend. Even with perfect frontend security, an
                                    attacker can bypass your UI and hit your API directly. Always validate, sanitize,
                                    and authorize every request on the server side.</p>
                            </div>
                        </div>
                        <p>Warning: Never use <code>ElementRef.nativeElement</code> to set properties like
                            <code>innerHTML</code> or <code>src</code>. Doing so bypasses Angular’s security layer
                            entirely and exposes your application to direct XSS attacks. Always prefer Angular data
                            binding (<code>[innerHTML]</code>).
                        </p>
                    </section>
                </article>

                <article class="docs-article" id="section-10">
                    <header class="docs-header">
                        <p class="h2 docs-heading">Section 10: Testing</p>
                    </header>
                    <hr>
                    <section class="docs-section" id="item-10-1">
                        <p class="h3">Testing Basics</p>
                        <p>Testing ensures that your application behaves as expected and helps prevent regressions (new
                            bugs introduced by changes). Angular was designed with testability in mind, providing a
                            robust suite of tools out of the box to verify logic at every level of the application.
                        </p>
                        <p class="h5">Three Levels of Testing</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Test Type</th>
                                        <th scope="col">Scope</th>
                                        <th scope="col">Tools</th>
                                        <th scope="col">Speed</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Unit Testing</th>
                                        <td>Isolated logic (pipes, services, single functions).</td>
                                        <td>Jasmine, Karma / Vitest</td>
                                        <td>Extremely Fast</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Component Testing</th>
                                        <td>Interaction between TS and HTML (DOM rendering).</td>
                                        <td>TestBed, Jasmine</td>
                                        <td>Fast</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">End-to-End (E2E)</th>
                                        <td>Full user journeys in a real browser.</td>
                                        <td>Cypress, Playwright</td>
                                        <td>Slow</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">1. The Core Tools</p>
                        <p>Angular projects are pre-configured with a specific testing stack, though modern developers
                            often swap parts of it for faster alternatives.</p>
                        <ul>
                            <li>Jasmine: The framework used to write the tests. It provides the syntax (e.g.,
                                <code>describe</code>, <code>it</code>, <code>expect</code>).
                            </li>
                            <li>Karma: The "test runner" that opens a browser, executes the Jasmine tests, and reports
                                the results.</li>
                            <li>TestBed: Angular's primary utility for configuring and initializing the environment for
                                unit testing components and services.</li>
                        </ul>
                        <p class="h5">2. Anatomy of a Test File (<code>.spec.ts</code>)</p>
                        <p>Every Angular file (component, service, pipe) usually comes with a corresponding
                            <code>.spec.ts</code> file.
                        </p>
                        <pre><code class="language-javascript">// sample.spec.ts
describe('AuthService', () =&gt; { // 1. The Test Suite
  let service: AuthService;

  beforeEach(() =&gt; { // 2. Setup logic before every test
    service = new AuthService();
  });

  it('should return true if token exists', () =&gt; { // 3. Individual Test Case
    localStorage.setItem('token', '123');
    const result = service.isLoggedIn();
    
    expect(result).toBe(true); // 4. Assertion (The expectation)
  });
});
</code></pre>
                        <p class="h5">3. Key Jasmine Functions</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Function</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>describe(string, fn)</code></td>
                                        <td>Groups related tests together into a suite.</td>
                                    </tr>
                                    <tr>
                                        <td><code>it(string, fn)</code></td>
                                        <td>Defines a single test case with a clear description.</td>
                                    </tr>
                                    <tr>
                                        <td><code>expect(actual)</code></td>
                                        <td>Starts an assertion to check a value.</td>
                                    </tr>
                                    <tr>
                                        <td><code>toBe(expected)</code></td>
                                        <td>Matcher for exact equality (===).</td>
                                    </tr>
                                    <tr>
                                        <td><code>toEqual(expected)</code></td>
                                        <td>Matcher for deep equality (useful for objects/arrays).</td>
                                    </tr>
                                    <tr>
                                        <td><code>beforeEach(fn)</code></td>
                                        <td>Runs a setup block before every <code>it()</code> in the suite.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">4. Running Tests</p>
                        <p>You execute your tests via the Angular CLI. By default, Karma will stay open and "watch" for
                            file changes, re-running your tests automatically.</p>
                        <ul>
                            <li>Command: <code>ng test</code></li>
                            <li>Code Coverage: <code>ng test --code-coverage</code> (Generates a report showing exactly
                                which lines of your code are not yet tested).</li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Modern Angular development is increasingly moving toward Vitest for unit testing
                                    because it is significantly faster than Karma/Jasmine. However, Jasmine remains the
                                    official default and is excellent for learning the fundamentals.</p>
                            </div>
                        </div>
                        <p>Warning: Don't aim for 100% code coverage just for the sake of the number. Focus your testing
                            efforts on business logic (services, calculations, and guards) rather than trivial code like
                            simple getters or boilerplate properties.</p>
                    </section>

                    <section class="docs-section" id="item-10-2">
                        <p class="h3">Component Testing</p>
                        <p>Component testing (also known as Integration Testing) is more complex than service testing
                            because it involves both the TypeScript class and the HTML Template. You aren't just testing
                            functions; you are verifying that data renders correctly in the DOM and that user events
                            (like clicks) trigger the expected logic.</p>
                        <p class="h5">1. The Angular TestBed</p>
                        <p>The <code>TestBed</code> is the most important utility in Angular testing. It creates a "test
                            module" that mocks the environment where your component lives, allowing you to "compile" the
                            component and its template for testing.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>fixture</code></td>
                                        <td>A wrapper around the component and its rendered DOM.</td>
                                    </tr>
                                    <tr>
                                        <td><code>componentInstance</code></td>
                                        <td>Provides access to the TypeScript class variables and methods.</td>
                                    </tr>
                                    <tr>
                                        <td><code>nativeElement</code></td>
                                        <td>Provides access to the underlying HTML element (DOM).</td>
                                    </tr>
                                    <tr>
                                        <td><code>detectChanges()</code></td>
                                        <td>Manually triggers Angular's change detection to update the HTML.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">2. Basic Component Test Structure</p>
                        <p>When you generate a component, Angular creates a <code>.spec.ts</code> boilerplate. Here is
                            how you use it to test a simple "Welcome" message.</p>
                        <pre><code class="language-javascript">describe('WelcomeComponent', () =&gt; {
  let component: WelcomeComponent;
  let fixture: ComponentFixture&lt;WelcomeComponent&gt;;

  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      imports: [WelcomeComponent] // Standalone components go here
    }).compileComponents();

    fixture = TestBed.createComponent(WelcomeComponent);
    component = fixture.componentInstance;
    fixture.detectChanges(); // Initial data binding
  });

  it('should display the correct username', () =&gt; {
    component.user = 'Alex';
    fixture.detectChanges(); // Update the HTML with the new name

    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Welcome, Alex');
  });
});
</code></pre>
                        <p class="h5">3. Testing User Interactions</p>
                        <p>To test user actions, you must simulate events on DOM elements and then check if the
                            component responded correctly.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col" style="width: 30%;">Action</th>
                                        <th scope="col" style="width: 70%;">Code Example</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><strong>Find Button</strong></th>
                                        <td>
                                            <code>const btn = fixture.nativeElement.querySelector('button');</code>
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>Simulate Click</strong></th>
                                        <td>
                                            <code>btn.click();</code>
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>Check Method</strong></th>
                                        <td>
                                            <code>expect(component.myMethod).toHaveBeenCalled();</code>
                                        </td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>Check Output</strong></th>
                                        <td>
                                            <code class="d-block mb-1">spyOn(component.saved, 'emit'); ...</code>
                                            <code>expect(component.saved.emit).toHaveBeenCalled();</code>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">4. Handling Dependencies (Mocks & Spies)</p>
                        <p>Components often rely on services. In a test, you should never use the real service
                            (especially if it makes HTTP calls). Instead, you use Spies or Mock Services.</p>
                        <pre><code class="language-javascript">// Mocking a service in TestBed
const mockAuthService = { isLoggedIn: () =&gt; true };

beforeEach(() =&gt; {
  TestBed.configureTestingModule({
    imports: [ProfileComponent],
    providers: [
      { provide: AuthService, useValue: mockAuthService }
    ]
  });
});
</code></pre>
                        <p class="h5">5. DebugElement vs. NativeElement</p>
                        <p>Angular provides two ways to look at the rendered output:</p>
                        <ul>
                            <li><code>nativeElement</code>: Standard Web API <code>HTMLElement</code>. Best for simple
                                queries (<code>querySelector</code>).</li>
                            <li><code>debugElement</code>: An Angular wrapper. Best for testing Angular-specific things,
                                like finding elements by a specific Directive or Component type.</li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p> If your component uses asynchronous operations (like <code>setTimeout</code> or
                                    Promises), you must wrap your test in <code>fakeAsync()</code> and use
                                    <code>tick()</code> to simulate the passage of time.
                                </p>
                            </div>
                        </div>
                        <p>Warning: Always remember to call <code>fixture.detectChanges()</code> after you change a
                            property in your test. Unlike the real browser, the test environment does not automatically
                            watch for changes; you must manually tell Angular to update the DOM.</p>
                    </section>

                    <section class="docs-section" id="item-10-3">
                        <p class="h3">Service & Pipe Testing</p>
                        <p>Testing Services and Pipes is generally straightforward because they are often "pure"
                            TypeScript classes or functions. They don't have templates or complex DOM interactions,
                            making them the fastest tests in your suite.
                        </p>
                        <p class="h5">1. Testing Pipes</p>
                        <p>Pipes are the easiest to test because they are simple classes with a <code>transform</code>
                            method. You don't even need
                            <code>TestBed</code> for basic pipe testing; you can simply instantiate the class.
                        </p>
                        <p class="h6">Example: Testing a "TitleCase" Pipe</p>
                        <pre><code class="language-javascript">import { TitleCasePipe } from './title-case.pipe';

describe('TitleCasePipe', () =&gt; {
  const pipe = new TitleCasePipe();

  it('should transform "angular rocks" to "Angular Rocks"', () =&gt; {
    expect(pipe.transform('angular rocks')).toBe('Angular Rocks');
  });

  it('should return an empty string if input is empty', () =&gt; {
    expect(pipe.transform('')).toBe('');
  });
});
</code></pre>
                        <p class="h5">2. Testing Services</p>
                        <p>Services often have dependencies (like <code>HttpClient</code>). When testing a service, we
                            use <code>TestBed.inject()</code> to get an instance of the service within the testing
                            environment.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Aspect</th>
                                        <th scope="col">Strategy</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Simple Service</strong></td>
                                        <td>Instantiate and test methods directly.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Service with Deps</strong></td>
                                        <td>Use <code>TestBed</code> to provide mock versions of dependencies.</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Async Logic</strong></td>
                                        <td>Use <code>subscribe</code> or <code>lastValueFrom</code> to verify
                                            Observable outputs.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">3. Mocking HTTP Requests</p>
                        <p>You should never make real network calls in a unit test. Angular provides the
                            <code>HttpTestingController</code> to mock API responses and verify that the correct URLs
                            were called.
                        </p>
                        <p class="h6">Example: Testing a Data Fetching Service</p>
                        <pre><code class="language-javascript">import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
import { DataService } from './data.service';

describe('DataService', () =&gt; {
  let service: DataService;
  let httpMock: HttpTestingController;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [DataService]
    });
    service = TestBed.inject(DataService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  it('should fetch data via GET', () =&gt; {
    const mockUsers = [{ id: 1, name: 'John' }];

    service.getUsers().subscribe(users =&gt; {
      expect(users.length).toBe(1);
      expect(users).toEqual(mockUsers);
    });

    // Verify the request URL
    const req = httpMock.expectOne('api/users');
    expect(req.request.method).toBe('GET');

    // Flush the mock data to the subscriber
    req.flush(mockUsers);
  });

  afterEach(() =&gt; {
    httpMock.verify(); // Ensures no outstanding requests remain
  });
});
</code></pre>
                        <p class="h5">4. Spying on Dependencies</p>
                        <p>If your service depends on another service (e.g., a <code>LoggerService</code>), use a
                            Jasmine Spy. This allows you to check if a method was called without executing the actual
                            code of the dependency.</p>
                        <pre><code class="language-javascript">it('should log a message when data is saved', () =&gt; {
  const loggerSpy = jasmine.createSpyObj('LoggerService', ['log']);
  const service = new DataService(loggerSpy);

  service.saveData({ id: 1 });
  
  expect(loggerSpy.log).toHaveBeenCalledWith('Data saved successfully');
});
</code></pre>
                        <p class="h6">Summary of Testing Utilities</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col" style="width: 30%;">Utility</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>TestBed.inject()</code></td>
                                        <td>Safely retrieves a service instance from the testing module.</td>
                                    </tr>
                                    <tr>
                                        <td><code>HttpClientTestingModule</code></td>
                                        <td>Replaces real HTTP logic with a testing mock.</td>
                                    </tr>
                                    <tr>
                                        <td><code>HttpTestingController</code></td>
                                        <td>Allows you to "flush" (send) fake data back to your service.</td>
                                    </tr>
                                    <tr>
                                        <td><code>jasmine.createSpyObj</code></td>
                                        <td>Quickly creates a mock object with specific methods to watch.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>When testing Observables in services, always ensure the test doesn't finish before
                                    the Observable emits. Using the <code>subscribe</code> block inside the
                                    <code>it</code> function is the standard way to handle this.
                                </p>
                            </div>
                        </div>
                        <p>Warning: Always call <code>httpMock.verify()</code> in an <code>afterEach</code> block. If
                            you don't, a test might pass even if your service accidentally triggered three extra API
                            calls that you didn't account for.</p>
                    </section>

                    <section class="docs-section" id="item-10-4">
                        <p class="h3">End-to-End Testing (e.g., Cypress/Playwright)</p>
                        <p>End-to-End (E2E) Testing is the final layer of the testing pyramid. Unlike unit tests that
                            check individual functions, E2E tests verify the entire application stack—frontend, backend,
                            and database—by automating a real browser to perform user actions.
                        </p>
                        <p class="h5">Why use E2E Testing?</p>
                        <p>While Unit and Component tests ensure the "parts" work, E2E tests ensure the "machine" works.
                        </p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Feature</th>
                                        <th scope="col">Unit Testing</th>
                                        <th scope="col">E2E Testing</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">Execution</th>
                                        <td>Isolated functions/components.</td>
                                        <td>Full browser environment.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Data</th>
                                        <td>Mocked/Fake data.</td>
                                        <td>Real or Staging database.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Speed</th>
                                        <td>Instant.</td>
                                        <td>Slower (requires app startup).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Confidence</th>
                                        <td>Low (doesn't check integration).</td>
                                        <td><strong>High</strong> (mimics real users).</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">1. Popular E2E Tools for Angular</p>
                        <p>Angular has moved away from its original tool (Protractor) in favor of modern,
                            industry-standard frameworks.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Tool</th>
                                        <th scope="col">Strengths</th>
                                        <th scope="col">Best For</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row"><strong>Playwright</strong></th>
                                        <td>Extremely fast, multi-browser support (Chromium, Firefox, WebKit), great
                                            auto-waiting.</td>
                                        <td>Modern enterprise apps and CI/CD pipelines.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row"><strong>Cypress</strong></th>
                                        <td>Amazing developer experience (DX), time-travel debugging, easy setup.</td>
                                        <td>Developers who want visual feedback while writing tests.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">2. Writing a Basic Test Case</p>
                        <p>E2E tests use a "Selector-Action-Assertion" pattern. You find an element, interact with it,
                            and check the result.</p>
                        <p class="h6">Example: A Login Flow (Playwright Syntax)</p>
                        <pre><code class="language-javascript">import { test, expect } from '@playwright/test';

test('should log in successfully with valid credentials', async ({ page }) =&gt; {
  // 1. Visit the page
  await page.goto('http://localhost:4200/login');

  // 2. Perform actions
  await page.fill('input[name="email"]', 'user@example.com');
  await page.fill('input[name="password"]', 'password123');
  await page.click('button[type="submit"]');

  // 3. Assert the result
  await expect(page).toHaveURL('http://localhost:4200/dashboard');
  await expect(page.locator('h1')).toContainText('Welcome back!');
});
</code></pre>
                        <p class="h5">3. Key Concepts in E2E</p>
                        <ul>
                            <li>Locators: Ways to find elements. It is a best practice to use Test IDs (e.g.,
                                <code>data-testid="login-btn</code>") rather than CSS classes, as classes change
                                frequently during styling updates.
                            </li>
                            <li>Auto-Waiting: Modern tools like Playwright and Cypress automatically wait for an element
                                to appear or an animation to finish before clicking, reducing "flaky" tests.</li>
                            <li>Headless Mode: Running tests without a visible browser window. This is how tests are run
                                on servers (CI/CD) to save memory and speed.</li>
                        </ul>
                        <p class="h5">4. Best Practices for E2E</p>
                        <ul>
                            <li>Test the "Happy Path": Focus on critical user journeys (Signup, Checkout, Login). You
                                don't need to test every edge case here; leave those for unit tests.</li>
                            <li>Clean State: Ensure each test starts from a fresh state. Don't let one test's data (like
                                a created user) interfere with the next test.</li>
                            <li>Avoid "Sleep" Commands: Never use <code>setTimeout</code> or <code>waitFor(5000)</code>.
                                Use built-in waiting mechanisms that trigger as soon as an element is ready.</li>
                        </ul>
                        <p class="h5">5. Running E2E Tests</p>
                        <p>In an Angular project, you can add these tools via the CLI:</p>
                        <ul>
                            <li>Cypress: <code>ng add @cypress/schematic</code></li>
                            <li>Playwright: <code>npm init playwright@latest</code></li>
                        </ul>
                        <p class="h6">Once installed, you typically run them using:</p>
                        <ul>
                            <li><code>npm run e2e</code> (to run all tests in the terminal)</li>
                            <li><code>npx cypress open</code> (to open the visual test runner)</li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p> E2E tests are expensive in terms of time and resources. A common strategy is to run
                                    Unit tests on every code change (Commit) and run the full E2E suite only before
                                    merging code (Pull Request) or deploying to production.</p>
                            </div>
                        </div>
                        <p>Warning: E2E tests are notoriously "flaky" (sometimes passing, sometimes failing for no clear
                            reason). This is often due to network latency or slow database responses. Always build
                            "retry" logic into your CI/CD pipeline to ensure a single network hiccup doesn't block your
                            entire deployment.</p>
                    </section>
                </article>

                <article class="docs-article" id="section-11">
                    <header class="docs-header">
                        <p class="h2 docs-heading">Section 11: Tooling & CLI</p>
                    </header>
                    <hr>
                    <section class="docs-section" id="item-11-1">
                        <p class="h3">Angular CLI Commands Reference</p>
                        <p>The Angular CLI (Command Line Interface) is the primary tool for initializing, developing,
                            scaffolding, and maintaining Angular applications. It automates repetitive tasks and ensures
                            that your project adheres to best practices and a consistent structure.</p>
                        <p class="h5">1. Essential Development Commands</p>
                        <p>These commands are used daily during the active development phase to manage the local server
                            and ensure code quality.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Command</th>
                                        <th scope="col">Alias</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>ng serve</code></td>
                                        <td><code>ng s</code></td>
                                        <td>
                                            Launches a local development server at
                                            <code>http://localhost:4200</code>. Supports
                                            <strong>Hot Module Replacement (HMR)</strong>.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>ng generate</code></td>
                                        <td><code>ng g</code></td>
                                        <td>Creates new files (components, services, etc.) using blueprints.</td>
                                    </tr>
                                    <tr>
                                        <td><code>ng test</code></td>
                                        <td><code>ng t</code></td>
                                        <td>Runs unit tests using the configured runner (default: Karma).</td>
                                    </tr>
                                    <tr>
                                        <td><code>ng lint</code></td>
                                        <td>—</td>
                                        <td>Runs static analysis to check for code style and potential errors.</td>
                                    </tr>
                                    <tr>
                                        <td><code>ng version</code></td>
                                        <td><code>ng v</code></td>
                                        <td>Displays the version of Angular CLI, Node.js, and package versions.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">2. Scaffolding (The <code>ng generate</code> Blueprint)</p>
                        <p>The <code>generate</code> command is highly versatile. It creates the TypeScript file, HTML,
                            CSS, and the spec (test) file automatically.</p>
                        <ul>
                            <li>Component: <code>ng g c path/name</code></li>
                            <li>Service: <code>ng g s path/name</code></li>
                            <li>Directive: <code>ng g d path/name</code></li>
                            <li>Pipe: <code>ng g p path/name</code></li>
                            <li>Guard: <code>ng g g path/name</code> (Prompts for type: CanActivate, etc.)</li>
                            <li>Interface: <code>ng g i path/name</code></li>
                            <li>Environment: <code>ng g environments</code> (Generates <code>environment.ts</code>
                                files)</li>
                        </ul>
                        <p class="h5">3. Build and Deployment</p>
                        <p>When you are ready to move your code to a server, use the build commands to compile the app
                            into static files.</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Command</th>
                                        <th scope="col">Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>ng build</code></td>
                                        <td>
                                            Compiles the application into the <code>dist/</code> folder.
                                            Uses production configuration by default in v17+.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>ng build --configuration=stage</code></td>
                                        <td>
                                            Builds using specific settings defined in <code>angular.json</code>.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>ng deploy</code></td>
                                        <td>
                                            Deploys the application to a supported cloud provider (e.g., Firebase,
                                            Vercel, Azure) using a specific schematics.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">4. Project Maintenance & Updates</p>
                        <p>Angular is known for its excellent update path. The CLI handles complex migrations of your
                            code when new versions are released.</p>
                        <ul>
                            <li><code>ng update</code>: Lists all packages that have available updates.</li>
                            <li><code>ng update @angular/core @angular/cli</code>: Performs a safe, automated update of
                                the core framework and the CLI tool, often including "migrations" that rewrite your code
                                to match new APIs.</li>
                            <li><code>ng add &lt;package&gt;</code>: Installs a library and automatically runs a script
                                to configure it within your project (e.g., <code>ng add @angular/material</code>).</li>
                        </ul>
                        <p class="h5">5. Advanced Productivity Flags</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Flag</th>
                                        <th scope="col">Effect</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>--dry-run</code></td>
                                        <td>Shows which files would be created/modified without actually writing them.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>--skip-tests</code></td>
                                        <td>Prevents the creation of <code>.spec.ts</code> files during generation.</td>
                                    </tr>
                                    <tr>
                                        <td><code>--inline-template</code></td>
                                        <td>Places the HTML inside the <code>.ts</code> file rather than a separate
                                            <code>.html</code> file.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><code>--open</code> (or <code>-o</code>)</td>
                                        <td>Automatically opens your browser when running <code>ng serve</code>.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Many commands support a "schematic" name. If you use a UI library like Ionic or
                                    Angular Material, they provide their own blueprints (e.g.,
                                    <code>ng g @angular/material:table my-table</code>).
                                </p>
                            </div>
                        </div>
                        <p>Warning: Always run <code>ng update</code> on a clean git branch. While the CLI is excellent
                            at migrating code, large version jumps can occasionally require manual intervention in
                            complex configurations.</p>
                    </section>

                    <section class="docs-section" id="item-11-2">
                        <p class="h3">Building for Production</p>
                        <p>When you run <code>ng serve</code>, the Angular CLI prioritizes build speed and debugging
                            features. However, for a production environment, the priorities shift to performance,
                            security, and minimal file size. Building for production involves a series of complex
                            optimizations that transform your development code into a highly efficient, browser-ready
                            bundle.</p>
                        <p class="h5">1. Key Production Optimizations</p>
                        <p>When you run <code>ng build</code>, Angular applies several critical techniques to ensure
                            your app is as fast as possible:</p>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Optimization</th>
                                        <th scope="col">Description</th>
                                        <th scope="col">Benefit</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row">AOT Compilation</th>
                                        <td>Compiles HTML and TypeScript into efficient JavaScript <em>before</em> the
                                            browser downloads it.</td>
                                        <td>Faster rendering; catches template errors at build time.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Tree Shaking</th>
                                        <td>Identifies and removes unused code from your application and third-party
                                            libraries.</td>
                                        <td>Significantly smaller bundle size.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Minification</th>
                                        <td>Removes whitespace, comments, and renames variables to shorter names.</td>
                                        <td>Reduces the number of bytes transferred.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Uglification</th>
                                        <td>Transforms code to make it difficult to read/reverse-engineer.</td>
                                        <td>Basic source code protection.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Dead Code Elimination</th>
                                        <td>Removes code that is unreachable (e.g., code inside an
                                            <code>if(false)</code> block).
                                        </td>
                                        <td>Streamlines execution.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">2. Configuration (angular.json)</p>
                        <p>The <code>angular.json</code> file contains a <code>configurations</code> object. By default,
                            Angular defines a <code>production</code> configuration that enables these optimizations.
                        </p>
                        <pre><code class="language-javascript">"configurations": {
  "production": {
    "optimization": true,
    "outputHashing": "all",
    "sourceMap": false,
    "namedChunks": false,
    "extractLicenses": true,
    "vendorChunk": false,
    "buildOptimizer": true
  }
}
</code></pre>
                        <ul>
                            <li><code>outputHashing</code>: Adds a unique hash to filenames (e.g.,
                                <code>main.7a2b3c.js</code>). This is vital for Cache Busting—ensuring users always get
                                the latest version when you deploy.
                            </li>
                            <li><code>sourceMap</code>: Disabled by default in production to prevent leaking your
                                original source code to the browser console.</li>
                        </ul>
                        <p class="h5">3. Environment Files</p>
                        <p>Production apps often need different settings than local ones (e.g., API URLs, logging
                            levels, or API keys). Angular uses environment-based file replacement to handle this.</p>
                        <ol>
                            <li>Generate environments: <code>ng generate environments</code></li>
                            <li>Edit <code>environment.ts</code> for development.</li>
                            <li>Edit <code>environment.prod.ts</code> for production.</li>
                        </ol>
                        <p class="h6">Usage in Code:</p>
                        <pre><code class="language-javascript">import { environment } from '../environments/environment';

export class ApiService {
  apiUrl = environment.apiUrl; // Automatically swaps based on build target
}
</code></pre>
                        <p class="h5">4. Build Analysis</p>
                        <p>To understand why your app is large, you can generate a Bundle Report. This helps you
                            identify "heavy" libraries that might be better replaced with lighter alternatives.</p>
                        <ol>
                            <li>Generate Stats: <code>ng build --stats-json</code></li>
                            <li>Visualize: Use a tool like <code>webpack-bundle-analyzer</code> or
                                <code>source-map-explorer</code>.
                            </li>
                        </ol>
                        <p class="h5">5. Deployment Checklist</p>
                        <ul>
                            <li>[ ] SSR/Prerendering: Have you enabled Server-Side Rendering for SEO?</li>
                            <li>[ ] Compression: Is your server (Nginx/Apache) configured to use Gzip or Brotli?</li>
                            <li>[ ] Base Href: If your app is not at the root (e.g., <code>mysite.com/my-app/</code>),
                                use <code>ng build --base-href /my-app/</code>.

                            </li>
                            <li>[ ] Cache Policy: Is your server configured to cache hashed files indefinitely?</li>
                            <li>[ ] Lazy Loading: Ensure you are using lazy loading to keep the initial "Main" bundle
                                small.</li>
                        </ul>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>Since Angular v17, the default builder is based on Esbuild. This makes production
                                    builds significantly faster (up to 80% faster in some cases) compared to the older
                                    Webpack-based builder.</p>
                            </div>
                        </div>
                        <p>Warning: Never include sensitive information like database passwords or private API keys in
                            your environment files. Even if minified, any code sent to the browser can be easily read by
                            a determined user.</p>
                    </section>
                    
                    <section class="docs-section" id="item-11-3">
                        <p class="h3">Deployment</p>
                        <p>Deployment is the final stage of the development lifecycle, where your compiled application
                            is moved from your local machine to a web server or cloud provider. Because Angular builds
                            result in static assets (HTML, CSS, JS), you have a wide variety of hosting options ranging
                            from simple static hosts to complex cloud environments.
                        </p>
                        <p class="h5">1. The Build Artifacts</p>
                        <p>When you run <code>ng build</code>, Angular generates a <code>dist/</code> folder. This
                            folder is self-contained and contains everything the browser needs to run your app.</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col" style="width: 30%;">File Type</th>
                                        <th scope="col">Purpose</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>index.html</code></td>
                                        <td>The entry point of your application.</td>
                                    </tr>
                                    <tr>
                                        <td><code>main.[hash].js</code></td>
                                        <td>Your application logic and framework code.</td>
                                    </tr>
                                    <tr>
                                        <td><code>polyfills.[hash].js</code></td>
                                        <td>Scripts that enable modern features in older browsers.</td>
                                    </tr>
                                    <tr>
                                        <td><code>styles.[hash].css</code></td>
                                        <td>The compiled and minified CSS of your application.</td>
                                    </tr>
                                    <tr>
                                        <td><code>assets/</code></td>
                                        <td>A directory for static files like images, fonts, and icons.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">2. Deployment Strategies</p>
                        <p>Depending on your application's architecture (CSR vs. SSR), your deployment strategy will
                            differ significantly.</p>
                        <div class="table-responsive">
                            <table class="table table-hover table-striped align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Strategy</th>
                                        <th scope="col">Best For</th>
                                        <th scope="col">Requirement</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <th scope="row" class="fw-bold">Static Hosting</th>
                                        <td>CSR or SSG apps.</td>
                                        <td>A basic web server (Nginx, S3, GitHub Pages).</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" class="fw-bold">Cloud Platforms</th>
                                        <td>Apps requiring easy scaling.</td>
                                        <td>Providers like Firebase, Vercel, or Netlify.</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" class="fw-bold">SSR / Node.js</th>
                                        <td>Dynamic SSR apps.</td>
                                        <td>A server capable of running Node.js (Docker, AWS EC2, Heroku).</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="h5">3. Automated Deployment (<code>ng deploy</code>)</p>
                        <p>The Angular CLI simplifies deployment through the <code>ng deploy</code> command. This uses
                            schematics to automate the build and upload process for specific providers.</p>
                        <p class="h6">Example for Firebase:</p>
                        <ol>
                            <li>Add the schematic: <code>ng add @angular/fire</code></li>
                            <li>Deploy: <code>ng deploy</code></li>
                        </ol>
                        <p class="h6">Commonly Supported Providers:</p>
                        <ul>
                            <li>Firebase Hosting: <code>ng add @angular/fire</code></li>
                            <li>Azure: <code>   ng add @azure/ng-deploy</code></li>
                            <li>AWS: <code>ng add @jscutlery/semver</code> (or similar community schematics)</li>
                            <li>Netlify / Vercel: Typically handled via Git-based CI/CD rather than a CLI command.</li>
                        </ul>
                        <p class="h5">4. Server Configuration (The "Fallback" Rule)</p>
                        <p>In a Single Page Application (SPA), the browser handles routing. If a user refreshes the page
                            at <code>mysite.com/dashboard</code>, the server will look for a file named
                            <code>dashboard</code> and return a 404 error because only <code>index.html</code> actually
                            exists.</p>
                        <p>The Solution: You must configure your server to redirect all requests to
                            <code>index.html</code>.</p>
                        <p class="h6">Nginx Configuration Example:</p>
                        <pre><code class="language-nginx">location / {
    try_files $uri $uri/ /index.html;
}
</code></pre>
                        <p class="h5">5. CI/CD Pipelines</p>
                        <p>In a professional setting, you rarely deploy manually. Instead, you use Continuous
                            Integration / Continuous Deployment (CI/CD) to automate the process whenever code is pushed
                            to your repository (e.g., GitHub, GitLab).</p>
                        <ol>
                            <li>Lint/Test: Ensure code quality and that no tests are broken.</li>
                            <li>Build: Run <code>ng build --configuration production</code>.</li>
                            <li>Upload: Move the <code>dist/</code> folder to your production server or CDN.</li>
                        </ol>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                        <i class="fas fa-info-circle"></i>
                                    </span>
                                    Note
                                </h4>
                                <p>If you are deploying an SSR application, you aren't just uploading static files. You
                                    are deploying a Node.js application. You will need to run
                                    <code>node dist/project-name/server/main.js</code> on your server to handle incoming
                                    requests.</p>
                            </div>
                        </div>
                        <p>Warning: Always check your Base Href. If your app is hosted at a sub-path (e.g.,
                            <code>company.com/portal/</code>), your build must reflect this:
                            <code>ng build --base-href /portal/</code>. Otherwise, the browser will fail to find your
                            JavaScript and CSS files.</p>
                    </section>
                </article>
            </div>
        </div>
    </div>
    <button id="docs-sidebar-toggler" class="floating docs-sidebar-toggler docs-sidebar-visible d-xl-none"
        type="button">
        <i class="fa fa-bars"></i>
    </button>
    <!--//docs-wrapper-->





    <!-- Javascript -->
    <script src="https://code.jquery.com/jquery-3.6.3.min.js"
        integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>

    <script src="../../docsallover/static/core/plugins/popper.min.js"></script>
    <script src="../../docsallover/static/core/plugins/bootstrap/js/bootstrap.min.js"></script>
    <script src="../../docsallover/static/core/fontawesome/js/all.min.js"></script>
    <script src="../../docsallover/static/core/plugins/simplelightbox/simple-lightbox.min.js"></script>



    <!-- Page Specific JS -->
    <script src="../../docsallover/static/core/plugins/smoothscroll.min.js"></script>
    <script src="../../docsallover/static/core/plugins/highlightjs/highlight.min.js"></script>
    <script src="../../docsallover/static/core/js/highlight-custom.js"></script>
    <script src="../../docsallover/static/core/plugins/gumshoe/gumshoe.polyfills.min.js"></script>
    <script src="../../docsallover/static/core/js/docs.js"></script>



    <script>
        $(document).ready(function () {
            $('[data-toggle="tooltip"]').tooltip();
        });
    </script>

</body>

</html>